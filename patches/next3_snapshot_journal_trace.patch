===next3_snapshot_journal_trace.patch===

next3: snapshot journaled - trace COW/buffer credits

Extra debug prints to trace snapshot usage of buffer credits.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/jbd/journal.c b/fs/jbd/journal.c
--- a/fs/jbd/journal.c	2010-07-26 09:21:55.904895878 +0300
+++ b/fs/jbd/journal.c	2010-07-26 09:21:55.334878133 +0300
@@ -1903,6 +1903,9 @@ void journal_put_journal_head(struct jou
 u8 journal_enable_debug __read_mostly;
 EXPORT_SYMBOL(journal_enable_debug);
 
+const u8 journal_handle_size = sizeof(handle_t);
+EXPORT_SYMBOL(journal_handle_size);
+
 static struct dentry *jbd_debugfs_dir;
 static struct dentry *jbd_debug;
 
diff -Nuarp a/fs/next3/next3_jbd.c b/fs/next3/next3_jbd.c
--- a/fs/next3/next3_jbd.c	2010-07-26 09:21:55.984890734 +0300
+++ b/fs/next3/next3_jbd.c	2010-07-26 09:21:55.414811882 +0300
@@ -16,6 +16,7 @@ int __next3_journal_get_undo_access(cons
 		err = next3_snapshot_get_undo_access(handle, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
+	next3_journal_trace(SNAP_DEBUG, where, handle, 1);
 	return err;
 }
 
@@ -27,6 +28,7 @@ int __next3_journal_get_write_access_ino
 		err = next3_snapshot_get_write_access(handle, inode, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
+	next3_journal_trace(SNAP_DEBUG, where, handle, 1);
 	return err;
 }
 
@@ -36,6 +38,7 @@ int __next3_journal_forget(const char *w
 	int err = journal_forget(handle, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
+	next3_journal_trace(SNAP_DEBUG, where, handle, 1);
 	return err;
 }
 
@@ -45,6 +48,7 @@ int __next3_journal_revoke(const char *w
 	int err = journal_revoke(handle, blocknr, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
+	next3_journal_trace(SNAP_DEBUG, where, handle, 1);
 	return err;
 }
 
@@ -56,6 +60,7 @@ int __next3_journal_get_create_access(co
 		err = next3_snapshot_get_create_access(handle, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
+	next3_journal_trace(SNAP_DEBUG, where, handle, -1);
 	return err;
 }
 
@@ -85,6 +90,7 @@ int __next3_journal_dirty_metadata(const
 		}
 		jbd_unlock_bh_state(bh);
 	}
+	next3_journal_trace(SNAP_DEBUG, where, handle, -1);
 	return err;
 }
 int __next3_journal_release_buffer(const char *where, handle_t *handle,
@@ -118,3 +124,69 @@ out:
 	return err;
 }
 
+#ifdef CONFIG_JBD_DEBUG
+static void next3_journal_cow_stats(int n, next3_handle_t *handle)
+{
+	if (!trace_cow_enabled())
+		return;
+	snapshot_debug(n, "COW stats: moved/copied=%d/%d, "
+			 "mapped/bitmap/cached=%d/%d/%d, "
+			 "bitmaps/cleared=%d/%d\n", handle->h_cow_moved,
+			 handle->h_cow_copied, handle->h_cow_ok_mapped,
+			 handle->h_cow_ok_bitmap, handle->h_cow_ok_jh,
+			 handle->h_cow_bitmaps, handle->h_cow_excluded);
+}
+#else
+#define next3_journal_cow_stats(n, handle)
+#endif
+
+#ifdef CONFIG_NEXT3_FS_DEBUG
+void __next3_journal_trace(int n, const char *fn, const char *caller,
+		next3_handle_t *handle, int nblocks)
+{
+	struct super_block *sb = handle->h_transaction->t_journal->j_private;
+	struct inode *active_snapshot = next3_snapshot_has_active(sb);
+	int upper = NEXT3_SNAPSHOT_START_TRANS_BLOCKS(handle->h_base_credits);
+	int lower = NEXT3_SNAPSHOT_TRANS_BLOCKS(handle->h_user_credits);
+	int final = (nblocks == 0 && handle->h_ref == 1 &&
+		     !IS_COWING(handle));
+
+	switch (snapshot_enable_debug) {
+	case SNAP_INFO:
+		/* trace final journal_stop if any credits have been used */
+		if (final && (handle->h_buffer_credits < upper ||
+			      handle->h_user_credits < handle->h_base_credits))
+			break;
+	case SNAP_WARN:
+		/*
+		 * trace if buffer credits are too low - lower limit is only
+		 * valid if there is an active snapshot and not during COW
+		 */
+		if (handle->h_buffer_credits < lower &&
+		    active_snapshot && !IS_COWING(handle))
+			break;
+	case SNAP_ERR:
+		/* trace if user credits are too low */
+		if (handle->h_user_credits < 0)
+			break;
+	case 0:
+		/* no trace */
+		return;
+
+	case SNAP_DEBUG:
+	default:
+		/* trace all calls */
+		break;
+	}
+
+	snapshot_debug_l(n, IS_COWING(handle), "%s(%d): credits=%d, limit=%d/%d,"
+			 " user=%d/%d, ref=%d, caller=%s\n", fn, nblocks,
+			 handle->h_buffer_credits, lower, upper,
+			 handle->h_user_credits, handle->h_base_credits,
+			 handle->h_ref, caller);
+	if (!final)
+		return;
+
+	next3_journal_cow_stats(n, handle);
+}
+#endif
diff -Nuarp a/fs/next3/next3_jbd.h b/fs/next3/next3_jbd.h
--- a/fs/next3/next3_jbd.h	2010-07-26 09:21:56.024824279 +0300
+++ b/fs/next3/next3_jbd.h	2010-07-26 09:21:55.454816368 +0300
@@ -180,6 +180,18 @@ struct next3_handle_s
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	h_lockdep_map;
 #endif
+
+#ifdef CONFIG_JBD_DEBUG
+	/* Statistics counters: */
+	unsigned int h_cow_moved; /* blocks moved to snapshot */
+	unsigned int h_cow_copied; /* blocks copied to snapshot */
+	unsigned int h_cow_ok_jh; /* blocks already COWed during current
+				     transaction */
+	unsigned int h_cow_ok_bitmap; /* blocks not set in COW bitmap */
+	unsigned int h_cow_ok_mapped;/* blocks already mapped in snapshot */
+	unsigned int h_cow_bitmaps; /* COW bitmaps created */
+	unsigned int h_cow_excluded; /* blocks set in exclude bitmap */
+#endif
 };
 
 #ifndef _NEXT3_HANDLE_T
@@ -190,8 +202,36 @@ typedef struct next3_handle_s		next3_han
 #define IS_COWING(handle) \
 	((next3_handle_t *)(handle))->h_cowing
 
+/*
+ * macros for next3 to update transaction COW statistics.
+ * when next3 is compiled as a module with CONFIG_JBD_DEBUG, if the symbol
+ * journal_handle_size doesn't exist or doesn't match the sizeof(handle_t),
+ * then the kernel was compiled wthout CONFIG_JBD_DEBUG or without the next3
+ * patch and the h_cow_* fields are not allocated in handle objects.
+ */
+#ifdef CONFIG_JBD_DEBUG
+extern const u8 journal_handle_size;
+
+#define trace_cow_enabled()	\
+	(journal_handle_size == sizeof(handle_t))
+
+#define trace_cow_add(handle, name, num)			\
+	do {							\
+		if (trace_cow_enabled())			\
+			((next3_handle_t *)(handle))->h_cow_##name += (num);	\
+	} while (0)
+
+#define trace_cow_inc(handle, name)				\
+	do {							\
+		if (trace_cow_enabled())			\
+			((next3_handle_t *)(handle))->h_cow_##name++;	\
+	} while (0)
+
+#else
+#define trace_cow_enabled()	0
 #define trace_cow_add(handle, name, num)
 #define trace_cow_inc(handle, name)
+#endif
 
 int
 next3_mark_iloc_dirty(handle_t *handle,
@@ -261,7 +301,20 @@ int __next3_journal_dirty_metadata(const
 
 int next3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);
 
+#ifdef CONFIG_NEXT3_FS_DEBUG
+void __next3_journal_trace(int debug, const char *fn, const char *caller,
+		next3_handle_t *handle, int nblocks);
+
+#define next3_journal_trace(n, caller, handle, nblocks)			\
+	do {								\
+		if ((n) <= snapshot_enable_debug)			\
+			__next3_journal_trace((n), __func__, (caller),	\
+				(next3_handle_t *)(handle), (nblocks));	\
+	} while (0)
+
+#else
 #define next3_journal_trace(n, caller, handle, nblocks)
+#endif
 
 handle_t *__next3_journal_start(const char *where,
 		struct super_block *sb, int nblocks);
diff -Nuarp a/fs/next3/super.c b/fs/next3/super.c
--- a/fs/next3/super.c	2010-07-26 09:21:55.994822417 +0300
+++ b/fs/next3/super.c	2010-07-26 09:21:55.434813250 +0300
@@ -129,6 +129,8 @@ int __next3_journal_stop(const char *whe
 	int err;
 	int rc;
 
+	next3_journal_trace(SNAP_WARN, where, handle, 0);
+
 	sb = handle->h_transaction->t_journal->j_private;
 	err = handle->h_err;
 	rc = journal_stop(handle);
diff -Nuarp a/include/linux/jbd.h b/include/linux/jbd.h
--- a/include/linux/jbd.h	2010-07-26 09:21:55.884892018 +0300
+++ b/include/linux/jbd.h	2010-07-26 09:21:55.314811868 +0300
@@ -387,6 +387,18 @@ struct handle_s
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	h_lockdep_map;
 #endif
+
+#ifdef CONFIG_JBD_DEBUG
+	/* Statistics counters: */
+	unsigned int h_cow_moved; /* blocks moved to snapshot */
+	unsigned int h_cow_copied; /* blocks copied to snapshot */
+	unsigned int h_cow_ok_jh; /* blocks already COWed during current
+				     transaction */
+	unsigned int h_cow_ok_bitmap; /* blocks not set in COW bitmap */
+	unsigned int h_cow_ok_mapped;/* blocks already mapped in snapshot */
+	unsigned int h_cow_bitmaps; /* COW bitmaps created */
+	unsigned int h_cow_excluded; /* blocks set in exclude bitmap */
+#endif
 };
 
 #ifndef _NEXT3_HANDLE_T
