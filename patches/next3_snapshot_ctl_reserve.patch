===next3_snapshot_ctl_reserve.patch===

next3: snapshot control - reserve disk space for snapshot

Ensure there is enough disk space for snapshot file future use.
Reserve disk space on snapshot take based on file system overhead
size, number of directories and number of blocks/inodes in use.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/balloc.c b/fs/next3/balloc.c
--- a/fs/next3/balloc.c	2010-07-26 09:22:00.314888986 +0300
+++ b/fs/next3/balloc.c	2010-07-26 09:21:59.814923434 +0300
@@ -1451,9 +1451,27 @@ out:
 static int next3_has_free_blocks(struct next3_sb_info *sbi)
 {
 	next3_fsblk_t free_blocks, root_blocks;
+	next3_fsblk_t snapshot_r_blocks;
+	handle_t *handle = journal_current_handle();
 
 	free_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	root_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);
+	if (handle && sbi->s_active_snapshot) {
+		snapshot_r_blocks =
+			le32_to_cpu(sbi->s_es->s_snapshot_r_blocks_count);
+		/*
+		 * snapshot reserved blocks for COWing to active snapshot
+		 */
+		if (free_blocks < snapshot_r_blocks + 1 &&
+		    !IS_COWING(handle)) {
+			return 0;
+		}
+		/*
+		 * mortal users must reserve blocks for both snapshot and
+		 * root user
+		 */
+		root_blocks += snapshot_r_blocks;
+	}
 	if (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&
 		sbi->s_resuid != current_fsuid() &&
 		(sbi->s_resgid == 0 || !in_group_p (sbi->s_resgid))) {
diff -Nuarp a/fs/next3/snapshot_ctl.c b/fs/next3/snapshot_ctl.c
--- a/fs/next3/snapshot_ctl.c	2010-07-26 09:22:00.434959879 +0300
+++ b/fs/next3/snapshot_ctl.c	2010-07-26 09:21:59.904937913 +0300
@@ -12,6 +12,7 @@
  * Next3 snapshots control functions.
  */
 
+#include <linux/statfs.h>
 #include "snapshot.h"
 
 /*
@@ -693,6 +694,8 @@ int next3_snapshot_take(struct inode *in
 	struct next3_inode *raw_inode;
 	int i;
 	int err = -EIO;
+	next3_fsblk_t snapshot_r_blocks;
+	struct kstatfs statfs;
 
 	if (!sbi->s_sbh)
 		goto out_err;
@@ -721,6 +724,32 @@ int next3_snapshot_take(struct inode *in
 	}
 
 	err = -EIO;
+	/* update fs statistics to calculate snapshot reserved space */
+	if (next3_statfs_sb(sb, &statfs)) {
+		snapshot_debug(1, "failed to statfs before snapshot (%u) "
+			       "take\n", inode->i_generation);
+		goto out_err;
+	}
+	/*
+	 * Calculate maximum disk space for snapshot file metadata based on:
+	 * 1 indirect block per 1K fs blocks (to map moved data blocks)
+	 * +1 data block per 1K fs blocks (to copy indirect blocks)
+	 * +1 data block per fs meta block (to copy meta blocks)
+	 * +1 data block per directory (to copy small directory index blocks)
+	 * +1 data block per 64 inodes (to copy large directory index blocks)
+	 * XXX: reserved space may be too small in data jounaling mode,
+	 *      which is currently not supported.
+	 */
+	snapshot_r_blocks = 2 * (statfs.f_blocks >>
+				 SNAPSHOT_ADDR_PER_BLOCK_BITS) +
+		statfs.f_spare[0] + statfs.f_spare[1] +
+		(statfs.f_files - statfs.f_ffree) / 64;
+
+	/* verify enough free space before taking the snapshot */
+	if (statfs.f_bfree < snapshot_r_blocks) {
+		err = -ENOSPC;
+		goto out_err;
+	}
 
 	/*
 	 * flush journal to disk and clear the RECOVER flag
@@ -844,6 +873,7 @@ fix_inode_copy:
 		goto out_unlockfs;
 
 	/* set as on-disk active snapshot */
+	sbi->s_es->s_snapshot_r_blocks_count = cpu_to_le32(snapshot_r_blocks);
 	sbi->s_es->s_snapshot_id =
 		cpu_to_le32(le32_to_cpu(sbi->s_es->s_snapshot_id)+1);
 	if (sbi->s_es->s_snapshot_id == 0)
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:00.434959879 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:21:59.904937913 +0300
@@ -311,6 +311,8 @@ extern next3_fsblk_t next3_get_inode_blo
 					   struct next3_iloc *iloc);
 
 /* super.c */
+struct kstatfs;
+extern int next3_statfs_sb(struct super_block *sb, struct kstatfs *buf);
 
 /* tests if @inode is a snapshot file */
 static inline int next3_snapshot_file(struct inode *inode)
diff -Nuarp a/fs/next3/super.c b/fs/next3/super.c
--- a/fs/next3/super.c	2010-07-26 09:22:00.374887814 +0300
+++ b/fs/next3/super.c	2010-07-26 09:21:59.864925906 +0300
@@ -2686,9 +2686,13 @@ restore_opts:
 	return err;
 }
 
-static int next3_statfs (struct dentry * dentry, struct kstatfs * buf)
+static int next3_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	return next3_statfs_sb(dentry->d_sb, buf);
+}
+
+int next3_statfs_sb(struct super_block *sb, struct kstatfs *buf)
 {
-	struct super_block *sb = dentry->d_sb;
 	struct next3_sb_info *sbi = NEXT3_SB(sb);
 	struct next3_super_block *es = sbi->s_es;
 	u64 fsid;
@@ -2741,6 +2745,16 @@ static int next3_statfs (struct dentry *
 	buf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);
 	if (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))
 		buf->f_bavail = 0;
+	if (sbi->s_active_snapshot) {
+		if (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count) +
+				le32_to_cpu(es->s_snapshot_r_blocks_count))
+			buf->f_bavail = 0;
+		else
+			buf->f_bavail -=
+				le32_to_cpu(es->s_snapshot_r_blocks_count);
+	}
+	buf->f_spare[0] = percpu_counter_sum_positive(&sbi->s_dirs_counter);
+	buf->f_spare[1] = sbi->s_overhead_last;
 	buf->f_files = le32_to_cpu(es->s_inodes_count);
 	buf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);
 	es->s_free_inodes_count = cpu_to_le32(buf->f_ffree);
