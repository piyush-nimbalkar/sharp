===next3_snapshot_file_huge.patch===

next3: snapshot file - increase maximum file size limit to 16TB

Files larger than 2TB use Ext4 huge_file flag to store i_blocks
in file system blocks units, so the upper limit on snapshot actual
size is increased from 512*2^32 = 2TB to 4K*2^32 = 16TB,
which is also the upper limit on file system size.
To map 2^32 logical blocks, 4 triple indirect blocks are used instead
of just one.  The extra 3 triple indirect blocks are stored in-place
of direct blocks, which are not in use by snapshot files.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:22:05.054961807 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:22:04.554956364 +0300
@@ -299,6 +299,7 @@ static int next3_block_to_path(struct in
 		double_blocks = (1 << (ptrs_bits * 2));
 	int n = 0;
 	int final = 0;
+	int tind;
 
 	if (i_block < 0) {
 		next3_warning (inode->i_sb, "next3_block_to_path", "block < 0");
@@ -320,6 +321,16 @@ static int next3_block_to_path(struct in
 		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
 		offsets[n++] = i_block & (ptrs - 1);
 		final = ptrs;
+	} else if (next3_snapshot_file(inode) &&
+			(tind = (i_block >> (ptrs_bits * 3))) <
+			NEXT3_SNAPSHOT_NTIND_BLOCKS) {
+		/* use up to 4 triple indirect blocks to map 2^32 blocks */
+		i_block -= (tind << (ptrs_bits * 3));
+		offsets[n++] = NEXT3_TIND_BLOCK + tind;
+		offsets[n++] = i_block >> (ptrs_bits * 2);
+		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
+		offsets[n++] = i_block & (ptrs - 1);
+		final = ptrs;
 	} else {
 		next3_warning(inode->i_sb, "next3_block_to_path", "block > big");
 	}
@@ -2564,6 +2575,13 @@ void next3_truncate(struct inode *inode)
 	unsigned blocksize = inode->i_sb->s_blocksize;
 	struct page *page;
 
+	/* prevent partial truncate of snapshot files */
+	if (next3_snapshot_file(inode) && inode->i_size != 0) {
+		snapshot_debug(1, "snapshot file (%lu) cannot be partly "
+				"truncated!\n", inode->i_ino);
+		return;
+	}
+
 	/* prevent truncate of files on snapshot list */
 	if (next3_snapshot_list(inode)) {
 		snapshot_debug(1, "snapshot (%u) cannot be truncated!\n",
@@ -2699,6 +2717,19 @@ do_indirects:
 		;
 	}
 
+	if (next3_snapshot_file(inode)) {
+		int i;
+
+		/* Kill the remaining snapshot file triple indirect trees */
+		for (i = 1; i < NEXT3_SNAPSHOT_NTIND_BLOCKS; i++) {
+			nr = i_data[NEXT3_TIND_BLOCK + i];
+			if (!nr)
+				continue;
+			next3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);
+			i_data[NEXT3_TIND_BLOCK + i] = 0;
+		}
+	}
+
 	next3_discard_reservation(inode);
 
 	mutex_unlock(&ei->truncate_mutex);
@@ -2933,6 +2964,28 @@ void next3_get_inode_flags(struct next3_
 		ei->i_flags |= NEXT3_DIRSYNC_FL;
 }
 
+static blkcnt_t next3_inode_blocks(struct next3_inode *raw_inode,
+		struct next3_inode_info *ei)
+{
+	blkcnt_t i_blocks;
+	struct inode *inode = &(ei->vfs_inode);
+
+	if (next3_snapshot_file(inode)) {
+		/* we never set i_blocks_high, but fsck may do it when it fixes
+		   i_blocks */
+		i_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |
+					le32_to_cpu(raw_inode->i_blocks_lo);
+		if (ei->i_flags & NEXT3_HUGE_FILE_FL) {
+			/* i_blocks represent file system block size */
+			return i_blocks  << (inode->i_blkbits - 9);
+		} else {
+			return i_blocks;
+		}
+	} else {
+		return le32_to_cpu(raw_inode->i_blocks_lo);
+	}
+}
+
 struct inode *next3_iget(struct super_block *sb, unsigned long ino)
 {
 	struct next3_iloc iloc;
@@ -2992,8 +3045,8 @@ struct inode *next3_iget(struct super_bl
 		 * recovery code: that's fine, we're about to complete
 		 * the process of deleting those. */
 	}
-	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
 	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
+	inode->i_blocks = next3_inode_blocks(raw_inode, ei);
 #ifdef NEXT3_FRAGMENTS
 	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
 	ei->i_frag_no = raw_inode->i_frag;
@@ -3017,6 +3070,18 @@ struct inode *next3_iget(struct super_bl
 		ei->i_data[block] = raw_inode->i_block[block];
 
 	if (next3_snapshot_file(inode)) {
+		/*
+		 * ei->i_data[] has more blocks than raw_inode->i_block[].
+		 * Snapshot files don't use the first NEXT3_NDIR_BLOCKS of
+		 * ei->i_data[] and store the extra blocks at the
+		 * begining of raw_inode->i_block[].
+		 */
+		for (block = NEXT3_N_BLOCKS; block < NEXT3_SNAPSHOT_N_BLOCKS;
+				block++) {
+			ei->i_data[block] =
+				raw_inode->i_block[block-NEXT3_N_BLOCKS];
+			ei->i_data[block-NEXT3_N_BLOCKS] = 0;
+		}
 		ei->i_next_snapshot_ino =
 			le32_to_cpu(raw_inode->i_next_snapshot);
 		/*
@@ -3103,6 +3168,46 @@ bad_inode:
 	return ERR_PTR(ret);
 }
 
+static int next3_inode_blocks_set(handle_t *handle,
+				struct next3_inode *raw_inode,
+				struct next3_inode_info *ei)
+{
+	struct inode *inode = &(ei->vfs_inode);
+	u64 i_blocks = inode->i_blocks;
+
+	if (i_blocks <= ~0U) {
+		/*
+		 * i_blocks can be represnted in a 32 bit variable
+		 * as multiple of 512 bytes
+		 */
+		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
+		raw_inode->i_blocks_high = 0;
+		ei->i_flags &= ~NEXT3_HUGE_FILE_FL;
+		return 0;
+	}
+	/* only snapshot files may be represented as huge files */
+	if (!next3_snapshot_file(inode))
+		return -EFBIG;
+
+	i_blocks = i_blocks >> (inode->i_blkbits - 9);
+	if (i_blocks <= ~0U) {
+		/*
+		 * i_blocks can be represnted in a 32 bit variable
+		 * as multiple of file system block size
+		 */
+		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
+		raw_inode->i_blocks_high = 0;
+		ei->i_flags |= NEXT3_HUGE_FILE_FL;
+		return 0;
+	}
+	
+	/*
+	 * there is no sense in storing a 48 bit representation of i_blocks
+	 * on a file system whose blocks address space is 32 bit
+	 */
+	return -EFBIG;
+}
+
 /*
  * Post the struct inode info into an on-disk inode location in the
  * buffer-cache.  This gobbles the caller's reference to the
@@ -3155,7 +3260,10 @@ static int next3_do_update_inode(handle_
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
 	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
 	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
-	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
+	if (next3_inode_blocks_set(handle, raw_inode, ei))
+		next3_warning(inode->i_sb, __func__,
+				"ino=%lu, i_blocks=%lld is too big",
+				inode->i_ino, (long long)inode->i_blocks);
 	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
 	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
 #ifdef NEXT3_FRAGMENTS
@@ -3210,6 +3318,17 @@ static int next3_do_update_inode(handle_
 		raw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);
 
 	if (next3_snapshot_file(inode)) {
+		/*
+		 * ei->i_data[] has more blocks than raw_inode->i_block[].
+		 * Snapshot files don't use the first NEXT3_NDIR_BLOCKS of
+		 * ei->i_data[] and store the extra blocks at the
+		 * begining of raw_inode->i_block[].
+		 */
+		for (block = NEXT3_N_BLOCKS; block < NEXT3_SNAPSHOT_N_BLOCKS;
+				block++) {
+			raw_inode->i_block[block-NEXT3_N_BLOCKS] =
+				ei->i_data[block];
+		}
 		raw_inode->i_next_snapshot =
 			cpu_to_le32(ei->i_next_snapshot_ino);
 		/* dynamic snapshot flags are not stored on-disk */
diff -Nuarp a/fs/next3/next3.h b/fs/next3/next3.h
--- a/fs/next3/next3.h	2010-07-26 09:22:05.104963101 +0300
+++ b/fs/next3/next3.h	2010-07-26 09:22:04.604952814 +0300
@@ -169,6 +169,19 @@ struct next3_group_desc
 #define	NEXT3_DIND_BLOCK			(NEXT3_IND_BLOCK + 1)
 #define	NEXT3_TIND_BLOCK			(NEXT3_DIND_BLOCK + 1)
 #define	NEXT3_N_BLOCKS			(NEXT3_TIND_BLOCK + 1)
+/*
+ * Snapshot files have different indirection mapping that can map up to 2^32
+ * logical blocks, so they can cover the mapped filesystem block address space.
+ * Next3 must use either 4K or 8K blocks (depending on PAGE_SIZE).
+ * With 8K blocks, 1 triple indirect block maps 2^33 logical blocks.
+ * With 4K blocks (the system default), each triple indirect block maps 2^30
+ * logical blocks, so 4 triple indirect blocks map 2^32 logical blocks.
+ * Snapshot files in small filesystems (<= 4G), use only 1 double indirect
+ * block to map the entire filesystem.
+ */
+#define	NEXT3_SNAPSHOT_NTIND_BLOCKS	4
+#define	NEXT3_SNAPSHOT_N_BLOCKS		(NEXT3_TIND_BLOCK + \
+					 NEXT3_SNAPSHOT_NTIND_BLOCKS)
 
 /*
  * Inode flags
@@ -356,7 +369,7 @@ struct next3_inode {
 	__le32	i_dtime;	/* Deletion Time */
 	__le16	i_gid;		/* Low 16 bits of Group Id */
 	__le16	i_links_count;	/* Links count */
-	__le32	i_blocks;	/* Blocks count */
+	__le32	i_blocks_lo;	/* Blocks count */
 	__le32	i_flags;	/* File flags */
 	union {
 		struct {
@@ -376,8 +389,7 @@ struct next3_inode {
 	__le32	i_faddr;	/* Fragment address */
 	union {
 		struct {
-			__u8	l_i_frag;	/* Fragment number */
-			__u8	l_i_fsize;	/* Fragment size */
+			__le16	l_i_blocks_high;/* Blocks count */
 			__u16	i_pad1;
 			__le16	l_i_uid_high;	/* these 2 fields    */
 			__le16	l_i_gid_high;	/* were reserved2[0] */
@@ -406,8 +418,7 @@ struct next3_inode {
 
 #if defined(__KERNEL__) || defined(__linux__)
 #define i_next_snapshot	osd1.linux1.l_i_next_snapshot
-#define i_frag		osd2.linux2.l_i_frag
-#define i_fsize		osd2.linux2.l_i_fsize
+#define i_blocks_high	osd2.linux2.l_i_blocks_high
 #define i_uid_low	i_uid
 #define i_gid_low	i_gid
 #define i_uid_high	osd2.linux2.l_i_uid_high
diff -Nuarp a/fs/next3/next3_i.h b/fs/next3/next3_i.h
--- a/fs/next3/next3_i.h	2010-07-26 09:22:05.104963101 +0300
+++ b/fs/next3/next3_i.h	2010-07-26 09:22:04.604952814 +0300
@@ -68,7 +68,7 @@ struct next3_block_alloc_info {
  * third extended file system inode data in memory
  */
 struct next3_inode_info {
-	__le32	i_data[15];	/* unconverted */
+	__le32	i_data[NEXT3_SNAPSHOT_N_BLOCKS]; /* unconverted */
 	__u32	i_flags;
 #ifdef NEXT3_FRAGMENTS
 	__u32	i_faddr;
diff -Nuarp a/fs/next3/super.c b/fs/next3/super.c
--- a/fs/next3/super.c	2010-07-26 09:22:05.084964268 +0300
+++ b/fs/next3/super.c	2010-07-26 09:22:04.585028616 +0300
@@ -1508,10 +1508,13 @@ static loff_t next3_max_size(int bits)
 	 * __u32 i_blocks representing the total number of
 	 * 512 bytes blocks of the file
 	 */
-	upper_limit = (1LL << 32) - 1;
-
-	/* total blocks in file system block size */
-	upper_limit >>= (bits - 9);
+	/*
+	 * We use 48 bit ext4_inode i_blocks
+	 * With EXT4_HUGE_FILE_FL set the i_blocks
+	 * represent total number of blocks in
+	 * file system block size
+	 */
+	upper_limit = (1LL << 48) - 1;
 
 
 	/* indirect blocks */
@@ -1526,7 +1529,7 @@ static loff_t next3_max_size(int bits)
 
 	res += 1LL << (bits-2);
 	res += 1LL << (2*(bits-2));
-	res += 1LL << (3*(bits-2));
+	res += NEXT3_SNAPSHOT_NTIND_BLOCKS * (1LL << (3*(bits-2)));
 	res <<= bits;
 	if (res > upper_limit)
 		res = upper_limit;
@@ -1710,6 +1713,16 @@ static int next3_fill_super (struct supe
 		       sb->s_id, le32_to_cpu(features));
 		goto failed_mount;
 	}
+	/*
+	 * Large file size enabled file system can only be mounted
+	 * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF
+	 */
+	if (!(sb->s_flags & MS_RDONLY) && sizeof(blkcnt_t) < sizeof(u64)) {
+		printk(KERN_ERR "NEXT3-fs: Filesystem with snapshots support "
+				"cannot be mounted RDWR without "
+				"CONFIG_LBDAF");
+		goto failed_mount;
+	}
 	blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);
 
 	/* Block size must be equal to page size */
