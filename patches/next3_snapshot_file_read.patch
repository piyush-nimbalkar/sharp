===next3_snapshot_file_read.patch===

next3: snapshot file - read through to block device

On active snapshot file page read, the function next3_get_block()
is called to map the page to a disk block.  If the page is not mapped
in the snapshot file a direct mapping to the block device is returned.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:22:06.594988348 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:22:06.094977501 +0300
@@ -806,6 +806,21 @@ int next3_get_blocks_handle(handle_t *ha
 	struct next3_inode_info *ei = NEXT3_I(inode);
 	int count = 0;
 	next3_fsblk_t first_block = 0;
+	int read_through = 0;
+	struct inode *prev_snapshot;
+
+	/* read through expected only to snapshot file */
+	BUG_ON(read_through && !next3_snapshot_file(inode));
+	if (next3_snapshot_file(inode))
+		/* normal or read through snapshot file access? */
+		read_through = next3_snapshot_get_inode_access(handle, inode,
+				iblock, maxblocks, create, &prev_snapshot);
+
+	if (read_through < 0) {
+		err = read_through;
+		goto out;
+	}
+	err = -EIO;
 
 
 	J_ASSERT(handle != NULL || create == 0);
@@ -866,6 +881,24 @@ int next3_get_blocks_handle(handle_t *ha
 			goto got_it;
 	}
 
+	/*
+	 * On read of snapshot file, an unmapped block is a peephole to prev
+	 * snapshot.  On read of active snapshot, an unmapped block is a
+	 * peephole to the block device.  On first block write, the peephole
+	 * is filled forever.
+	 */
+	if (read_through && !err) {
+		if (next3_snapshot_is_active(inode)) {
+			/* active snapshot - read though holes to block
+			 * device */
+			clear_buffer_new(bh_result);
+			map_bh(bh_result, inode->i_sb, SNAPSHOT_BLOCK(iblock));
+			err = 1;
+			goto cleanup;
+		} else
+			err = -EIO;
+	}
+
 	/* Next simple case - plain lookup or failed read of indirect block */
 	if (!create || err == -EIO)
 		goto cleanup;
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:22:06.674987589 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:22:06.184976969 +0300
@@ -15,4 +15,51 @@
 #include "snapshot.h"
 
 
+/*
+ * next3_snapshot_get_inode_access() - called from next3_get_blocks_handle()
+ * on snapshot file access.
+ * return value <0 indicates access not granted
+ * return value 0 indicates normal inode access
+ * return value 1 indicates snapshot inode read through access
+ * in which case 'prev_snapshot' is pointed to the previous snapshot
+ * on the list or set to NULL to indicate read through to block device.
+ */
+int next3_snapshot_get_inode_access(handle_t *handle, struct inode *inode,
+		next3_fsblk_t iblock, int count, int cmd,
+		struct inode **prev_snapshot)
+{
+	struct next3_inode_info *ei = NEXT3_I(inode);
+	unsigned int flags = ei->i_flags;
+
+	if (!(flags & NEXT3_SNAPFILE_LIST_FL)) {
+		return 0;
+	}
+
+	if (cmd) {
+		/* snapshot inode write access */
+		snapshot_debug(1, "snapshot (%u) is read-only"
+				" - write access denied!\n",
+				inode->i_generation);
+		return -EPERM;
+	} else {
+		/* snapshot inode read access */
+		if (iblock < SNAPSHOT_BLOCK_OFFSET)
+			/* snapshot reserved blocks */
+			return 0;
+		/*
+		 * non NULL handle indicates this is test_and_cow()
+		 * checking if snapshot block is mapped
+		 */
+		if (handle)
+			return 0;
+	}
+
+	/*
+	 * Snapshot image read through access: (!cmd && !handle)
+	 * indicates this is next3_snapshot_readpage()
+	 * calling next3_snapshot_get_block()
+	 */
+	*prev_snapshot = NULL;
+	return next3_snapshot_is_active(inode) ? 1 : 0;
+}
 
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:06.694987819 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:06.194984817 +0300
@@ -197,6 +197,11 @@ static inline int next3_snapshot_get_del
 	return next3_snapshot_move(handle, inode, block, count, 1);
 }
 
+extern int next3_snapshot_get_inode_access(handle_t *handle,
+					   struct inode *inode,
+					   next3_fsblk_t iblock,
+					   int count, int cmd,
+					   struct inode **prev_snapshot);
 
 /*
  * Snapshot constructor/destructor
