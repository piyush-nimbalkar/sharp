==next3_snapshot_list.patch==

next3: snapshot list support

Implementation of multiple incremental snapshots.
Snapshot inodes are chained on a list starting at the super block,
both on-disk and in-memory, similar to the orphan inodes.  We reuse
the orphan inode list functions to manipulate the snapshot list.
Unlink and truncate of snapshot inodes on the list is not allowed,
so an inode can never be chained on both orphan and snapshot lists.
We make use of this fact to overload the in-memory inode field
next3_inode_info.i_orphan for the chaining of snapshots.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/namei.c b/fs/next3/namei.c
--- a/fs/next3/namei.c	2010-07-26 09:21:55.414811882 +0300
+++ b/fs/next3/namei.c	2010-07-26 09:21:54.834804969 +0300
@@ -1931,9 +1931,26 @@ static int empty_dir (struct inode * ino
  * At filesystem recovery time, we walk this list deleting unlinked
  * inodes and truncating linked inodes in next3_orphan_cleanup().
  */
+/*
+ * On errors, next3_std_error() is called and transaction is aborted.
+ */
 int next3_orphan_add(handle_t *handle, struct inode *inode)
 {
 	struct super_block *sb = inode->i_sb;
+	/*
+	 * only get the field address from the super block structs
+	 * the content of the field will only be changed under lock_super()
+	 */
+	return next3_inode_list_add(handle, inode, &NEXT_ORPHAN(inode),
+			&NEXT3_SB(sb)->s_es->s_last_orphan,
+			&NEXT3_SB(sb)->s_orphan, "orphan");
+}
+
+int next3_inode_list_add(handle_t *handle, struct inode *inode,
+		__le32 *i_next, __le32 *s_last,
+		struct list_head *s_list, const char *name)
+{
+	struct super_block *sb = inode->i_sb;
 	struct next3_iloc iloc;
 	int err = 0, rc;
 
@@ -1962,9 +1979,12 @@ int next3_orphan_add(handle_t *handle, s
 	if (err)
 		goto out_unlock;
 
-	/* Insert this inode at the head of the on-disk orphan list... */
-	NEXT_ORPHAN(inode) = le32_to_cpu(NEXT3_SB(sb)->s_es->s_last_orphan);
-	NEXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
+	snapshot_debug(4, "add inode %lu to %s list\n",
+			inode->i_ino, name);
+
+	/* Insert this inode at the head of the on-disk inode list... */
+	*i_next = le32_to_cpu(*s_last);
+	*s_last = cpu_to_le32(inode->i_ino);
 	err = next3_journal_dirty_metadata(handle, NEXT3_SB(sb)->s_sbh);
 	rc = next3_mark_iloc_dirty(handle, inode, &iloc);
 	if (!err)
@@ -1979,11 +1999,12 @@ int next3_orphan_add(handle_t *handle, s
 	 * This is safe: on error we're going to ignore the orphan list
 	 * anyway on the next recovery. */
 	if (!err)
-		list_add(&NEXT3_I(inode)->i_orphan, &NEXT3_SB(sb)->s_orphan);
+		list_add(&NEXT3_I(inode)->i_orphan, s_list);
 
-	jbd_debug(4, "superblock will point to %lu\n", inode->i_ino);
-	jbd_debug(4, "orphan inode %lu will point to %d\n",
-			inode->i_ino, NEXT_ORPHAN(inode));
+	snapshot_debug(4, "last_%s will point to inode %lu\n",
+			name, inode->i_ino);
+	snapshot_debug(4, "%s inode %lu will point to inode %d\n",
+			name, inode->i_ino, *i_next);
 out_unlock:
 	unlock_super(sb);
 	next3_std_error(inode->i_sb, err);
@@ -1996,6 +2017,23 @@ out_unlock:
  */
 int next3_orphan_del(handle_t *handle, struct inode *inode)
 {
+	struct super_block *sb = inode->i_sb;
+	/*
+	 * only get the field address from the super block structs
+	 * the content of the field will only be changed under lock_super()
+	 */
+	return next3_inode_list_del(handle, inode, &NEXT_ORPHAN(inode),
+			&NEXT3_SB(sb)->s_es->s_last_orphan,
+			&NEXT3_SB(sb)->s_orphan, "orphan");
+}
+
+#define NEXT_INODE_OFFSET (((char *)inode)-((char *)i_next))
+#define NEXT_INODE(i_prev) (*(__le32 *)(((char *)i_prev)-NEXT_INODE_OFFSET))
+
+int next3_inode_list_del(handle_t *handle, struct inode *inode,
+		__le32 *i_next, __le32 *s_last,
+		struct list_head *s_list, const char *name)
+{
 	struct list_head *prev;
 	struct next3_inode_info *ei = NEXT3_I(inode);
 	struct next3_sb_info *sbi;
@@ -2005,15 +2043,18 @@ int next3_orphan_del(handle_t *handle, s
 
 	lock_super(inode->i_sb);
 	if (list_empty(&ei->i_orphan)) {
+		snapshot_debug(4, "next3_orphan_del() called with inode %lu "
+			       "not in %s list\n", inode->i_ino, name);
 		unlock_super(inode->i_sb);
 		return 0;
 	}
 
-	ino_next = NEXT_ORPHAN(inode);
+	ino_next = *i_next;
 	prev = ei->i_orphan.prev;
 	sbi = NEXT3_SB(inode->i_sb);
 
-	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
+	snapshot_debug(4, "remove inode %lu from %s list\n", inode->i_ino,
+		       name);
 
 	list_del_init(&ei->i_orphan);
 
@@ -2028,30 +2069,31 @@ int next3_orphan_del(handle_t *handle, s
 	if (err)
 		goto out_err;
 
-	if (prev == &sbi->s_orphan) {
-		jbd_debug(4, "superblock will point to %lu\n", ino_next);
+	if (prev == s_list) {
+		snapshot_debug(4, "last_%s will point to inode %lu\n", name,
+				ino_next);
 		BUFFER_TRACE(sbi->s_sbh, "get_write_access");
 		err = next3_journal_get_write_access(handle, sbi->s_sbh);
 		if (err)
 			goto out_brelse;
-		sbi->s_es->s_last_orphan = cpu_to_le32(ino_next);
+		*s_last = cpu_to_le32(ino_next);
 		err = next3_journal_dirty_metadata(handle, sbi->s_sbh);
 	} else {
 		struct next3_iloc iloc2;
 		struct inode *i_prev =
 			&list_entry(prev, struct next3_inode_info, i_orphan)->vfs_inode;
 
-		jbd_debug(4, "orphan inode %lu will point to %lu\n",
-			  i_prev->i_ino, ino_next);
+		snapshot_debug(4, "%s inode %lu will point to inode %lu\n",
+			  name, i_prev->i_ino, ino_next);
 		err = next3_reserve_inode_write(handle, i_prev, &iloc2);
 		if (err)
 			goto out_brelse;
-		NEXT_ORPHAN(i_prev) = ino_next;
+		NEXT_INODE(i_prev) = ino_next;
 		err = next3_mark_iloc_dirty(handle, i_prev, &iloc2);
 	}
 	if (err)
 		goto out_brelse;
-	NEXT_ORPHAN(inode) = 0;
+	*i_next = 0;
 	err = next3_mark_iloc_dirty(handle, inode, &iloc);
 
 out_err:
diff -Nuarp a/fs/next3/next3_sb.h b/fs/next3/next3_sb.h
--- a/fs/next3/next3_sb.h	2010-07-26 09:21:55.464814716 +0300
+++ b/fs/next3/next3_sb.h	2010-07-26 09:21:54.894807033 +0300
@@ -95,6 +95,7 @@ struct next3_sb_info {
 	struct next3_group_info *s_group_info;	/* [ sb_bgl_lock ] */
 	struct mutex s_snapshot_mutex;		/* protects 2 fields below: */
 	struct inode *s_active_snapshot;	/* [ s_snapshot_mutex ] */
+	struct list_head s_snapshot_list;	/* [ s_snapshot_mutex ] */
 	unsigned long s_commit_interval;
 	struct block_device *journal_bdev;
 #ifdef CONFIG_JBD_DEBUG
diff -Nuarp a/fs/next3/snapshot_ctl.c b/fs/next3/snapshot_ctl.c
--- a/fs/next3/snapshot_ctl.c	2010-07-26 09:21:55.484814424 +0300
+++ b/fs/next3/snapshot_ctl.c	2010-07-26 09:21:54.914877510 +0300
@@ -372,11 +372,18 @@ static int next3_snapshot_create(struct 
 	next3_fsblk_t bmap_blk = 0, imap_blk = 0, inode_blk = 0;
 	next3_fsblk_t prev_inode_blk = 0;
 	loff_t snapshot_blocks = le32_to_cpu(sbi->s_es->s_blocks_count);
-	if (active_snapshot) {
-		snapshot_debug(1, "failed to add snapshot because active "
-			       "snapshot (%u) has to be deleted first\n",
-			       active_snapshot->i_generation);
-		return -EINVAL;
+	struct list_head *l, *list = &sbi->s_snapshot_list;
+
+	if (!list_empty(list)) {
+		struct inode *last_snapshot =
+			&list_first_entry(list, struct next3_inode_info,
+					  i_snaplist)->vfs_inode;
+		if (active_snapshot != last_snapshot) {
+			snapshot_debug(1, "failed to add snapshot because last"
+				       " snapshot (%u) is not active\n",
+				       last_snapshot->i_generation);
+			return -EINVAL;
+		}
 	}
 
 	/* prevent take of unlinked snapshot file */
@@ -440,14 +447,29 @@ static int next3_snapshot_create(struct 
 		NEXT3_SET_RO_COMPAT_FEATURE(sb,
 			NEXT3_FEATURE_RO_COMPAT_HAS_SNAPSHOT);
 
-	lock_super(sb);
-	err = next3_journal_get_write_access(handle, sbi->s_sbh);
-	sbi->s_es->s_snapshot_list = inode->i_ino;
-	if (!err)
-		err = next3_journal_dirty_metadata(handle, sbi->s_sbh);
-	unlock_super(sb);
-	if (err)
+	/* add snapshot list reference */
+	if (!igrab(inode)) {
+		err = -EIO;
+		goto out_handle;
+	}
+	/*
+	 * First, the snapshot is added to the in-memory and on-disk list.
+	 * At the end of snapshot_take(), it will become the active snapshot
+	 * in-memory and on-disk.
+	 * Finally, if snapshot_create() or snapshot_take() has failed,
+	 * snapshot_update() will remove it from the in-memory and on-disk list.
+	 */
+	err = next3_inode_list_add(handle, inode, &NEXT_SNAPSHOT(inode),
+			&sbi->s_es->s_snapshot_list,
+			list, "snapshot");
+	/* add snapshot list reference */
+	if (err) {
+		snapshot_debug(1, "failed to add snapshot (%u) to list\n",
+			       inode->i_generation);
+		iput(inode);
 		goto out_handle;
+	}
+	l = list->next;
 
 	err = next3_mark_inode_dirty(handle, inode);
 	if (err)
@@ -594,8 +616,10 @@ next_snapshot:
 			err = -EIO;
 		goto out_handle;
 	}
-	if (ino == NEXT3_ROOT_INO) {
-		ino = inode->i_ino;
+	if (l != list) {
+		ino = list_entry(l, struct next3_inode_info,
+				i_snaplist)->vfs_inode.i_ino;
+		l = l->next;
 		goto alloc_inode_blocks;
 	}
 
@@ -689,6 +713,8 @@ static char *copy_inode_block_name[COPY_
  */
 int next3_snapshot_take(struct inode *inode)
 {
+	struct list_head *list = &NEXT3_SB(inode->i_sb)->s_snapshot_list;
+	struct list_head *l = list->next;
 	struct super_block *sb = inode->i_sb;
 	struct next3_sb_info *sbi = NEXT3_SB(sb);
 	struct next3_super_block *es = NULL;
@@ -866,8 +892,10 @@ fix_inode_copy:
 	mark_buffer_dirty(sbh);
 	sync_dirty_buffer(sbh);
 
-	if (curr_inode->i_ino == NEXT3_ROOT_INO) {
-		curr_inode = inode;
+	if (l != list) {
+		curr_inode = &list_entry(l, struct next3_inode_info,
+				       i_snaplist)->vfs_inode;
+		l = l->next;
 		goto copy_inode_blocks;
 	}
 
@@ -1056,14 +1084,14 @@ static int next3_snapshot_remove(struct 
 	if (err)
 		goto out_handle;
 
-	lock_super(inode->i_sb);
-	err = next3_journal_get_write_access(handle, sbi->s_sbh);
-	sbi->s_es->s_snapshot_list = 0;
-	if (!err)
-		err = next3_journal_dirty_metadata(handle, sbi->s_sbh);
-	unlock_super(inode->i_sb);
+	err = next3_inode_list_del(handle, inode, &NEXT_SNAPSHOT(inode),
+			&sbi->s_es->s_snapshot_list,
+			&NEXT3_SB(inode->i_sb)->s_snapshot_list,
+			"snapshot");
 	if (err)
 		goto out_handle;
+	/* remove snapshot list reference - taken on snapshot_create() */
+	iput(inode);
 	/*
 	 * At this point, this snapshot is empty and not on the snapshots list.
 	 * As long as it was on the list it had to have the LIST flag to prevent
@@ -1127,6 +1155,10 @@ int next3_snapshot_load(struct super_blo
 	int err, num = 0, snapshot_id = 0;
 	int has_snapshot = 1, has_active = 0;
 
+	if (!list_empty(&NEXT3_SB(sb)->s_snapshot_list)) {
+		snapshot_debug(1, "warning: snapshots already loaded!\n");
+		return -EINVAL;
+	}
 
 	/* Migrate super block on-disk format */
 	if (NEXT3_HAS_RO_COMPAT_FEATURE(sb,
@@ -1252,8 +1284,10 @@ int next3_snapshot_load(struct super_blo
 			has_active = 1;
 		}
 
-		iput(inode);
-		break;
+		list_add_tail(&NEXT3_I(inode)->i_snaplist,
+			      &NEXT3_SB(sb)->s_snapshot_list);
+		ino_next = &NEXT_SNAPSHOT(inode);
+		/* keep snapshot list reference */
 	}
 
 	if (err) {
@@ -1280,6 +1314,16 @@ int next3_snapshot_load(struct super_blo
  */
 void next3_snapshot_destroy(struct super_block *sb)
 {
+	struct list_head *l, *n;
+	/* iterate safe because we are deleting from list and freeing the
+	 * inodes */
+	list_for_each_safe(l, n, &NEXT3_SB(sb)->s_snapshot_list) {
+		struct inode *inode = &list_entry(l, struct next3_inode_info,
+						  i_snaplist)->vfs_inode;
+		list_del_init(&NEXT3_I(inode)->i_snaplist);
+		/* remove snapshot list reference */
+		iput(inode);
+	}
 	/* deactivate in-memory active snapshot - cannot fail */
 	(void) next3_snapshot_set_active(sb, NULL);
 }
@@ -1299,6 +1343,11 @@ int next3_snapshot_update(struct super_b
 	struct inode *active_snapshot = next3_snapshot_has_active(sb);
 	struct inode *used_by = NULL; /* last non-deleted snapshot found */
 	int deleted;
+	struct inode *inode;
+	struct next3_inode_info *ei;
+	int found_active = 0;
+	int found_enabled = 0;
+	struct list_head *prev;
 	int err = 0;
 
 	BUG_ON(read_only && cleanup);
@@ -1306,6 +1355,73 @@ int next3_snapshot_update(struct super_b
 		NEXT3_I(active_snapshot)->i_flags |=
 			NEXT3_SNAPFILE_ACTIVE_FL|NEXT3_SNAPFILE_LIST_FL;
 
+	/* iterate safe from oldest snapshot backwards */
+	prev = NEXT3_SB(sb)->s_snapshot_list.prev;
+	if (list_empty(prev))
+		return 0;
+
+update_snapshot:
+	ei = list_entry(prev, struct next3_inode_info, i_snaplist);
+	inode = &ei->vfs_inode;
+	prev = ei->i_snaplist.prev;
+
+	/* all snapshots on the list have the LIST flag */
+	ei->i_flags |= NEXT3_SNAPFILE_LIST_FL;
+	/* set the 'No_Dump' flag on all snapshots */
+	ei->i_flags |= NEXT3_NODUMP_FL;
+
+	/*
+	 * snapshots later than active (failed take) should be removed.
+	 * no active snapshot means failed first snapshot take.
+	 */
+	if (found_active || !active_snapshot) {
+		if (!read_only)
+			err = next3_snapshot_remove(inode);
+		goto prev_snapshot;
+	}
+
+	deleted = ei->i_flags & NEXT3_SNAPFILE_DELETED_FL;
+	if (!deleted && read_only)
+		/* auto enable snapshots on readonly mount */
+		next3_snapshot_enable(inode);
+
+	/*
+	 * after completion of a snapshot management operation,
+	 * only the active snapshot can have the ACTIVE flag
+	 */
+	if (inode == active_snapshot) {
+		ei->i_flags |= NEXT3_SNAPFILE_ACTIVE_FL;
+		found_active = 1;
+		deleted = 0;
+	} else
+		ei->i_flags &= ~NEXT3_SNAPFILE_ACTIVE_FL;
+
+	if (found_enabled)
+		/* snapshot is in use by an older enabled snapshot */
+		ei->i_flags |= NEXT3_SNAPFILE_INUSE_FL;
+	else
+		/* snapshot is not in use by older enabled snapshots */
+		ei->i_flags &= ~NEXT3_SNAPFILE_INUSE_FL;
+
+	if (cleanup && deleted && !used_by)
+		/* remove permanently unused deleted snapshot */
+		err = next3_snapshot_remove(inode);
+
+	if (!deleted) {
+		if (!found_active)
+			/* newer snapshots are potentially used by
+			 * this snapshot (when it is enabled) */
+			used_by = inode;
+		if (ei->i_flags & NEXT3_SNAPFILE_ENABLED_FL)
+			found_enabled = 1;
+	}
+
+prev_snapshot:
+	if (err)
+		return err;
+	/* update prev snapshot */
+	if (prev != &NEXT3_SB(sb)->s_snapshot_list)
+		goto update_snapshot;
 
 	if (!active_snapshot || !cleanup || used_by)
 		return 0;
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:21:55.494812986 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:21:54.924837142 +0300
@@ -306,6 +306,12 @@ extern struct buffer_head *read_block_bi
 					     unsigned int block_group);
 
 /* namei.c */
+extern int next3_inode_list_add(handle_t *handle, struct inode *inode,
+				__le32 *i_next, __le32 *s_last,
+				struct list_head *s_list, const char *name);
+extern int next3_inode_list_del(handle_t *handle, struct inode *inode,
+				__le32 *i_next, __le32 *s_last,
+				struct list_head *s_list, const char *name);
 
 /* inode.c */
 extern next3_fsblk_t next3_get_inode_block(struct super_block *sb,
diff -Nuarp a/fs/next3/super.c b/fs/next3/super.c
--- a/fs/next3/super.c	2010-07-26 09:21:55.434813250 +0300
+++ b/fs/next3/super.c	2010-07-26 09:21:54.864804380 +0300
@@ -2019,6 +2019,7 @@ static int next3_fill_super (struct supe
 	INIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */
 	mutex_init(&sbi->s_snapshot_mutex);
 	sbi->s_active_snapshot = NULL;
+	INIT_LIST_HEAD(&sbi->s_snapshot_list); /* snapshot files */
 
 	sb->s_root = NULL;
 
