===next3_snapshot_hooks_jbd.patch===

next3: snapshot hooks - inside JBD hooks

Before every meta data buffer write, the journal API is called,
namely, one of the next3_journal_get_XXX_access() functions.
We use these journal hooks to call the snapshot API,
before every meta data buffer write.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:22:08.635016064 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:22:08.145007415 +0300
@@ -701,7 +701,8 @@ static int next3_splice_branch(handle_t 
 	 */
 	if (where->bh) {
 		BUFFER_TRACE(where->bh, "get_write_access");
-		err = next3_journal_get_write_access(handle, where->bh);
+		err = next3_journal_get_write_access_inode(handle, inode,
+							   where->bh);
 		if (err)
 			goto err_out;
 	}
@@ -2092,7 +2093,7 @@ static void next3_clear_blocks(handle_t 
 		next3_journal_test_restart(handle, inode);
 		if (bh) {
 			BUFFER_TRACE(bh, "retaking write access");
-			next3_journal_get_write_access(handle, bh);
+			next3_journal_get_write_access_inode(handle, inode, bh);
 		}
 	}
 
@@ -2153,7 +2154,8 @@ static void next3_free_data(handle_t *ha
 
 	if (this_bh) {				/* For indirect block */
 		BUFFER_TRACE(this_bh, "get_write_access");
-		err = next3_journal_get_write_access(handle, this_bh);
+		err = next3_journal_get_write_access_inode(handle, inode,
+							   this_bh);
 		/* Important: if we can't update the indirect pointers
 		 * to the blocks, we can't free them. */
 		if (err)
@@ -2310,8 +2312,8 @@ static void next3_free_branches(handle_t
 				 * pointed to by an indirect block: journal it
 				 */
 				BUFFER_TRACE(parent_bh, "get_write_access");
-				if (!next3_journal_get_write_access(handle,
-								   parent_bh)){
+				if (!next3_journal_get_write_access_inode(
+					    handle, inode, parent_bh)){
 					*p = 0;
 					BUFFER_TRACE(parent_bh,
 					"call next3_journal_dirty_metadata");
diff -Nuarp a/fs/next3/next3_jbd.c b/fs/next3/next3_jbd.c
--- a/fs/next3/next3_jbd.c	2010-07-26 09:22:08.655015188 +0300
+++ b/fs/next3/next3_jbd.c	2010-07-26 09:22:08.165011522 +0300
@@ -12,15 +12,19 @@ int __next3_journal_get_undo_access(cons
 				struct buffer_head *bh)
 {
 	int err = journal_get_undo_access(handle, bh);
+	if (!err)
+		err = next3_snapshot_get_undo_access(handle, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
 	return err;
 }
 
-int __next3_journal_get_write_access(const char *where, handle_t *handle,
-				struct buffer_head *bh)
+int __next3_journal_get_write_access_inode(const char *where, handle_t *handle,
+				struct inode *inode, struct buffer_head *bh)
 {
 	int err = journal_get_write_access(handle, bh);
+	if (!err)
+		err = next3_snapshot_get_write_access(handle, inode, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
 	return err;
@@ -48,6 +52,8 @@ int __next3_journal_get_create_access(co
 				handle_t *handle, struct buffer_head *bh)
 {
 	int err = journal_get_create_access(handle, bh);
+	if (!err)
+		err = next3_snapshot_get_create_access(handle, bh);
 	if (err)
 		next3_journal_abort_handle(where, __func__, bh, handle,err);
 	return err;
diff -Nuarp a/fs/next3/next3_jbd.h b/fs/next3/next3_jbd.h
--- a/fs/next3/next3_jbd.h	2010-07-26 09:22:08.705087137 +0300
+++ b/fs/next3/next3_jbd.h	2010-07-26 09:22:08.205010235 +0300
@@ -128,8 +128,8 @@ void next3_journal_abort_handle(const ch
 int __next3_journal_get_undo_access(const char *where, handle_t *handle,
 				struct buffer_head *bh);
 
-int __next3_journal_get_write_access(const char *where, handle_t *handle,
-				struct buffer_head *bh);
+int __next3_journal_get_write_access_inode(const char *where, handle_t *handle,
+				struct inode *inode, struct buffer_head *bh);
 
 int __next3_journal_forget(const char *where, handle_t *handle,
 				struct buffer_head *bh);
@@ -146,7 +146,10 @@ int __next3_journal_dirty_metadata(const
 #define next3_journal_get_undo_access(handle, bh) \
 	__next3_journal_get_undo_access(__func__, (handle), (bh))
 #define next3_journal_get_write_access(handle, bh) \
-	__next3_journal_get_write_access(__func__, (handle), (bh))
+	__next3_journal_get_write_access_inode(__func__, (handle), NULL, (bh))
+#define next3_journal_get_write_access_inode(handle, inode, bh) \
+	__next3_journal_get_write_access_inode(__func__, (handle), (inode), \
+					       (bh))
 #define next3_journal_revoke(handle, blocknr, bh) \
 	__next3_journal_revoke(__func__, (handle), (blocknr), (bh))
 #define next3_journal_get_create_access(handle, bh) \
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:08.725019746 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:08.235011696 +0300
@@ -96,6 +96,56 @@
  * Block access functions
  */
 
+/*
+ * get_write_access() is called before writing to a metadata block
+ * if @inode is not NULL, then this is an inode's indirect block
+ * otherwise, this is a file system global metadata block
+ *
+ * Return values:
+ * = 0 - block was COWed or doesn't need to be COWed
+ * < 0 - error
+ */
+static inline int next3_snapshot_get_write_access(handle_t *handle,
+		struct inode *inode, struct buffer_head *bh)
+{
+	return next3_snapshot_cow(handle, inode, bh, 1);
+}
+
+/*
+ * called from next3_journal_get_undo_access(),
+ * which is called for group bitmap block from:
+ * 1. next3_free_blocks_sb_inode() before deleting blocks
+ * 2. next3_new_blocks() before allocating blocks
+ *
+ * Return values:
+ * = 0 - block was COWed or doesn't need to be COWed
+ * < 0 - error
+ */
+static inline int next3_snapshot_get_undo_access(handle_t *handle,
+		struct buffer_head *bh)
+{
+	return next3_snapshot_cow(handle, NULL, bh, 1);
+}
+
+/*
+ * get_create_access() is called after allocating a new metadata block
+ *
+ * Return values:
+ * = 0 - block was COWed or doesn't need to be COWed
+ * < 0 - error
+ */
+static inline int next3_snapshot_get_create_access(handle_t *handle,
+		struct buffer_head *bh)
+{
+	/*
+	 * This block shouldn't need to be COWed if get_delete_access() was
+	 * called for all deleted blocks.  However, it may need to be COWed
+	 * if fsck was run and if it had freed some blocks without moving them
+	 * to snapshot.  In the latter case, -EIO will be returned.
+	 */
+	return next3_snapshot_cow(handle, NULL, bh, 0);
+}
+
 
 /*
  * Snapshot constructor/destructor
