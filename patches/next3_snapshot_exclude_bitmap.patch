===next3_snapshot_exclude_bitmap.patch===

next3: snapshot exclude - the exclude bitmap

Excluding blocks is done by setting their bit in the exclude bitmap.
There is one exclude bitmap block per block group and its location
is cached in the group descriptor.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/balloc.c b/fs/next3/balloc.c
--- a/fs/next3/balloc.c	2010-07-26 09:21:50.244733726 +0300
+++ b/fs/next3/balloc.c	2010-07-26 09:21:49.634723647 +0300
@@ -175,6 +175,56 @@ read_block_bitmap(struct super_block *sb
 	 */
 	return bh;
 }
+
+/**
+ * read_exclude_bitmap()
+ * @sb:			super block
+ * @block_group:	given block group
+ *
+ * Read the exclude bitmap for a given block_group
+ *
+ * Return buffer_head on success or NULL in case of failure.
+ */
+struct buffer_head *
+read_exclude_bitmap(struct super_block *sb, unsigned int block_group)
+{
+	struct next3_group_info *gi = NEXT3_SB(sb)->s_group_info + block_group;
+	struct buffer_head *bh = NULL;
+	next3_fsblk_t exclude_bitmap_blk;
+
+	exclude_bitmap_blk = gi->bg_exclude_bitmap;
+	if (!exclude_bitmap_blk)
+		return NULL;
+	bh = sb_getblk(sb, exclude_bitmap_blk);
+	if (unlikely(!bh)) {
+		next3_error(sb, __func__,
+			    "Cannot read exclude bitmap - "
+			    "block_group = %d, exclude_bitmap = %lu",
+			    block_group, exclude_bitmap_blk);
+		return NULL;
+	}
+	if (likely(bh_uptodate_or_lock(bh)))
+		return bh;
+
+	if (bh_submit_read(bh) < 0) {
+		brelse(bh);
+		next3_error(sb, __func__,
+			    "Cannot read exclude bitmap - "
+			    "block_group = %d, exclude_bitmap = %lu",
+			    block_group, exclude_bitmap_blk);
+		return NULL;
+	}
+	return bh;
+}
+
+/*
+ * dummy exclude inode is passed to next3_journal_get_write_access_inode()
+ * to ensure that exclude bitmap will not be COWed.
+ */
+static struct inode dummy_exclude_inode = {
+	.i_ino = NEXT3_EXCLUDE_INO
+};
+
 /*
  * The reservation window structure operations
  * --------------------------------------------
@@ -494,6 +544,12 @@ void __next3_free_blocks_sb_inode(const 
 	int err = 0, ret;
 	next3_grpblk_t group_freed;
 	next3_grpblk_t group_skipped = 0;
+	struct buffer_head *exclude_bitmap_bh = NULL;
+	int  exclude_bitmap_dirty = 0;
+	/* excluded_file is an attribute of the inode */
+	int excluded_file = next3_snapshot_excluded(inode);
+	/* excluded_block is determined by testing exclude bitmap */
+	int excluded_block;
 
 	*pdquot_freed_blocks = 0;
 	sbi = NEXT3_SB(sb);
@@ -564,6 +620,22 @@ do_more:
 	if (err)
 		goto error_return;
 
+	/*
+	 * we may be freeing blocks of snapshot/excluded file
+	 * which we would need to clear from exclude bitmap -
+	 * try to read exclude bitmap and if it fails
+	 * skip the exclude bitmap update
+	 */
+	brelse(exclude_bitmap_bh);
+	exclude_bitmap_bh = read_exclude_bitmap(sb, block_group);
+	if (exclude_bitmap_bh) {
+		err = next3_journal_get_write_access_inode(
+			handle, &dummy_exclude_inode, exclude_bitmap_bh);
+		if (err)
+			goto error_return;
+		exclude_bitmap_dirty = 0;
+	}
+
 	jbd_lock_bh_state(bitmap_bh);
 
 	for (i = 0, group_freed = 0; i < count; i++) {
@@ -646,6 +718,37 @@ do_more:
 		} else {
 			group_freed++;
 		}
+		/*
+		 * A free block should never be excluded from snapshot, so we
+		 * always clear exclude bitmap just to be on the safe side.
+		 */
+		excluded_block = (exclude_bitmap_bh &&
+			next3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),
+				bit + i, exclude_bitmap_bh->b_data)) ? 1 : 0;
+		if ((excluded_block && !excluded_file) ||
+			(excluded_file && !excluded_block)) {
+			jbd_unlock_bh_state(bitmap_bh);
+			/*
+			 * Freeing an excluded block of a non-excluded file
+			 * or a non-excluded block of an excluded file.  The
+			 * status of this block is now correct (not excluded),
+			 * but this indicates a messed up exclude bitmap.
+			 * mark that exclude bitmap needs to be fixed and call
+			 * next3_error() which commits the super block.
+			 */
+			NEXT3_SET_FLAGS(sb, NEXT3_FLAGS_FIX_EXCLUDE);
+			next3_error(sb, __func__,
+				"%sexcluded file (ino=%lu) block [%lu/%lu] "
+				"was %sexcluded! - "
+				"run fsck to fix exclude bitmap.\n",
+				excluded_file ? "" : "non-",
+				inode ? inode->i_ino : 0,
+				bit + i, block_group,
+				excluded_block ? "" : "not ");
+			jbd_lock_bh_state(bitmap_bh);
+		}
+		if (excluded_block)
+			exclude_bitmap_dirty = 1;
 	}
 	jbd_unlock_bh_state(bitmap_bh);
 
@@ -661,6 +764,11 @@ do_more:
 	ret = next3_journal_dirty_metadata(handle, bitmap_bh);
 	if (!err)
 		err = ret;
+	if (exclude_bitmap_bh && exclude_bitmap_dirty) {
+		ret = next3_journal_dirty_metadata(handle, exclude_bitmap_bh);
+		if (!err)
+			err = ret;
+	}
 
 	/* And the group descriptor block */
 	BUFFER_TRACE(gd_bh, "dirtied group descriptor block");
@@ -675,6 +783,7 @@ do_more:
 	}
 
 error_return:
+	brelse(exclude_bitmap_bh);
 	brelse(bitmap_bh);
 	next3_std_error(sb, err);
 	return;
@@ -852,6 +961,7 @@ find_next_usable_block(next3_grpblk_t st
  */
 static inline int
 claim_block(struct super_block *sb, int group, spinlock_t *lock,
+		struct buffer_head *exclude_bitmap_bh,
 		next3_grpblk_t block, struct buffer_head *bh)
 {
 	struct journal_head *jh = bh2jh(bh);
@@ -866,6 +976,34 @@ claim_block(struct super_block *sb, int 
 	} else {
 		ret = 1;
 	}
+	/*
+	 * Mark excluded file block in exclude bitmap.  Perhaps it would have
+	 * been better to mark the block excluded before marking it allocated
+	 * or to mark both under jbd_lock_bh_state(), to avoid the temporary
+	 * in-consistent state of a snapshot file block not marked excluded.
+	 * However, this kind of in-consistency can be neglected because when
+	 * the exclude bitmap is used for creating the COW bitmap it is masked
+	 * with the frozen copy of block bitmap in b_committed_data, where this
+	 * block is not marked allocated.
+	 */
+	if (ret && exclude_bitmap_bh &&
+		next3_set_bit_atomic(lock, block, exclude_bitmap_bh->b_data)) {
+		/*
+		 * We should never get here because free blocks
+		 * should never be excluded from snapshot.
+		 * the status of this block is now correct (excluded),
+		 * but this indicates a messed up exclude bitmap.
+		 * mark that exclude bitmap needs to be fixed and call
+		 * next3_error() which commits the super block.
+		 */
+		jbd_unlock_bh_state(bh);
+		NEXT3_SET_FLAGS(sb, NEXT3_FLAGS_FIX_EXCLUDE);
+		next3_error(sb, __func__,
+			"new allocated block [%d/%d] is excluded! - "
+			"run fsck to fix exclude bitmap.\n",
+			block, group);
+		return ret;
+	}
 	jbd_unlock_bh_state(bh);
 	return ret;
 }
@@ -897,6 +1035,7 @@ claim_block(struct super_block *sb, int 
 static next3_grpblk_t
 next3_try_to_allocate(struct super_block *sb, handle_t *handle, int group,
 			struct buffer_head *bitmap_bh,
+			struct buffer_head *exclude_bitmap_bh,
 			next3_grpblk_t grp_goal,
 			unsigned long *count, struct next3_reserve_window *my_rsv)
 {
@@ -949,6 +1088,7 @@ repeat:
 	start = grp_goal;
 
 	if (!claim_block(sb, group, sb_bgl_lock(sbi, group),
+		exclude_bitmap_bh,
 		grp_goal, bitmap_bh)) {
 		/*
 		 * The block was allocated by another thread, or it was
@@ -965,6 +1105,7 @@ repeat:
 	while (num < *count && grp_goal < end
 		&& next3_test_allocatable(grp_goal, bitmap_bh)
 		&& claim_block(sb, group, sb_bgl_lock(sbi, group),
+				exclude_bitmap_bh,
 				grp_goal, bitmap_bh)) {
 		num++;
 		grp_goal++;
@@ -1331,11 +1472,13 @@ static void try_to_extend_reservation(st
  */
 static next3_grpblk_t
 next3_try_to_allocate_with_rsv(struct super_block *sb, handle_t *handle,
+			struct inode *inode,
 			unsigned int group, struct buffer_head *bitmap_bh,
 			next3_grpblk_t grp_goal,
 			struct next3_reserve_window_node * my_rsv,
 			unsigned long *count, int *errp)
 {
+	struct buffer_head *exclude_bitmap_bh = NULL;
 	next3_fsblk_t group_first_block, group_last_block;
 	next3_grpblk_t ret = 0;
 	int fatal;
@@ -1355,6 +1498,24 @@ next3_try_to_allocate_with_rsv(struct su
 		return -1;
 	}
 
+	if (next3_snapshot_excluded(inode)) {
+		/*
+		 * allocating blocks for excluded file - try to read exclude
+		 * bitmap
+		 */
+		exclude_bitmap_bh = read_exclude_bitmap(sb, group);
+		if (exclude_bitmap_bh) {
+			fatal = next3_journal_get_write_access_inode(
+					handle, &dummy_exclude_inode,
+					exclude_bitmap_bh);
+			if (fatal) {
+				brelse(exclude_bitmap_bh);
+				*errp = fatal;
+				return -1;
+			}
+		}
+	}
+
 	/*
 	 * we don't deal with reservation when
 	 * filesystem is mounted without reservation
@@ -1363,6 +1524,7 @@ next3_try_to_allocate_with_rsv(struct su
 	 */
 	if (my_rsv == NULL ) {
 		ret = next3_try_to_allocate(sb, handle, group, bitmap_bh,
+						exclude_bitmap_bh,
 						grp_goal, count, NULL);
 		goto out;
 	}
@@ -1419,6 +1581,7 @@ next3_try_to_allocate_with_rsv(struct su
 			BUG();
 		}
 		ret = next3_try_to_allocate(sb, handle, group, bitmap_bh,
+					   exclude_bitmap_bh,
 					   grp_goal, &num, &my_rsv->rsv_window);
 		if (ret >= 0) {
 			my_rsv->rsv_alloc_hit += num;
@@ -1432,6 +1595,10 @@ out:
 		BUFFER_TRACE(bitmap_bh, "journal_dirty_metadata for "
 					"bitmap block");
 		fatal = next3_journal_dirty_metadata(handle, bitmap_bh);
+		if (!fatal && exclude_bitmap_bh)
+			fatal = next3_journal_dirty_metadata(handle,
+						     exclude_bitmap_bh);
+		brelse(exclude_bitmap_bh);
 		if (fatal) {
 			*errp = fatal;
 			return -1;
@@ -1439,6 +1606,9 @@ out:
 		return ret;
 	}
 
+	if (exclude_bitmap_bh)
+		fatal = next3_journal_release_buffer(handle, exclude_bitmap_bh);
+	brelse(exclude_bitmap_bh);
 	BUFFER_TRACE(bitmap_bh, "journal_release_buffer");
 	if (!fatal)
 		fatal = next3_journal_release_buffer(handle, bitmap_bh);
@@ -1616,6 +1786,7 @@ retry_alloc:
 		if (!bitmap_bh)
 			goto io_error;
 		grp_alloc_blk = next3_try_to_allocate_with_rsv(sb, handle,
+					inode,
 					group_no, bitmap_bh, grp_target_blk,
 					my_rsv,	&num, &fatal);
 		if (fatal)
@@ -1655,6 +1826,7 @@ retry_alloc:
 		 * try to allocate block(s) from this group, without a goal(-1).
 		 */
 		grp_alloc_blk = next3_try_to_allocate_with_rsv(sb, handle,
+					inode,
 					group_no, bitmap_bh, -1, my_rsv,
 					&num, &fatal);
 		if (fatal)
diff -Nuarp a/fs/next3/next3.h b/fs/next3/next3.h
--- a/fs/next3/next3.h	2010-07-26 09:21:50.314808664 +0300
+++ b/fs/next3/next3.h	2010-07-26 09:21:49.714847577 +0300
@@ -460,6 +460,7 @@ struct next3_inode {
 #define EXT2_FLAGS_TEST_FILESYS		0x0004	/* to test development code */
 #define NEXT3_FLAGS_IS_SNAPSHOT		0x0010 /* Is a snapshot image */
 #define NEXT3_FLAGS_FIX_SNAPSHOT	0x0020 /* Corrupted snapshot */
+#define NEXT3_FLAGS_FIX_EXCLUDE		0x0040 /* Bad exclude bitmap */
 #define NEXT3_FLAGS_BIG_JOURNAL		0x1000  /* Old big journal */
 
 #define NEXT3_SET_FLAGS(sb,mask) \
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:21:50.354736243 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:21:49.744726157 +0300
@@ -323,6 +323,7 @@ next3_snapshot_init_cow_bitmap(struct su
 		unsigned int block_group, struct buffer_head *cow_bh)
 {
 	struct buffer_head *bitmap_bh;
+	struct buffer_head *exclude_bitmap_bh = NULL;
 	char *dst, *src, *mask = NULL;
 	struct journal_head *jh;
 
@@ -331,6 +332,10 @@ next3_snapshot_init_cow_bitmap(struct su
 		return -EIO;
 
 	src = bitmap_bh->b_data;
+	exclude_bitmap_bh = read_exclude_bitmap(sb, block_group);
+	if (exclude_bitmap_bh)
+		/* mask block bitmap with exclude bitmap */
+		mask = exclude_bitmap_bh->b_data;
 	/*
 	 * Another COWing task may be changing this block bitmap
 	 * (allocating active snapshot blocks) while we are trying
@@ -358,6 +363,7 @@ next3_snapshot_init_cow_bitmap(struct su
 	jbd_unlock_bh_state(bitmap_bh);
 	jbd_unlock_bh_journal_head(bitmap_bh);
 
+	brelse(exclude_bitmap_bh);
 	brelse(bitmap_bh);
 	return 0;
 }
@@ -570,9 +576,110 @@ next3_snapshot_test_cow_bitmap(handle_t 
 			break;
 	}
 
+	if (inuse && excluded) {
+		int i, err;
+
+		/* don't COW excluded inode blocks */
+		if (!NEXT3_HAS_COMPAT_FEATURE(excluded->i_sb,
+			NEXT3_FEATURE_COMPAT_EXCLUDE_INODE))
+			/* no exclude inode/bitmap */
+			return 0;
+		/*
+		 * We should never get here because excluded file blocks should
+		 * be excluded from COW bitmap.  The blocks will not be COWed
+		 * anyway, but this can indicate a messed up exclude bitmap.
+		 * Mark that exclude bitmap needs to be fixed and clear blocks
+		 * from COW bitmap.
+		 */
+		NEXT3_SET_FLAGS(excluded->i_sb, NEXT3_FLAGS_FIX_EXCLUDE);
+		next3_warning(excluded->i_sb, __func__,
+			"clearing excluded file (ino=%lu) blocks [%d-%d/%lu] "
+			"from COW bitmap! - running fsck to fix exclude bitmap "
+			"is recommended.\n",
+			excluded->i_ino, bit, bit+inuse-1, block_group);
+		for (i = 0; i < inuse; i++)
+			next3_clear_bit(bit+i, cow_bh->b_data);
+		err = next3_journal_dirty_data(handle, cow_bh);
+		mark_buffer_dirty(cow_bh);
+		return err;
+	}
+
 	return inuse;
 }
 
+/*
+ * next3_snapshot_test_and_exclude() marks blocks in exclude bitmap
+ * @where:	name of caller function
+ * @handle:	JBD handle
+ * @sb:		super block handle
+ * @block:	address of first block to exclude
+ * @maxblocks:	max. blocks to exclude
+ * @exclude:	if false, return -EIO if block needs to be excluded
+ *
+ * Return values:
+ * >= 0 - no. of blocks set in exclude bitmap
+ * < 0 - error
+ */
+int next3_snapshot_test_and_exclude(const char *where, handle_t *handle,
+		struct super_block *sb, next3_fsblk_t block, int maxblocks,
+		int exclude)
+{
+	struct buffer_head *exclude_bitmap_bh = NULL;
+	unsigned long block_group = SNAPSHOT_BLOCK_GROUP(block);
+	next3_grpblk_t bit = SNAPSHOT_BLOCK_GROUP_OFFSET(block);
+	int err = 0, n = 0, excluded = 0;
+	int count = maxblocks;
+
+	exclude_bitmap_bh = read_exclude_bitmap(sb, block_group);
+	if (!exclude_bitmap_bh)
+		return 0;
+
+	if (exclude)
+		err = next3_journal_get_write_access(handle, exclude_bitmap_bh);
+	if (err)
+		goto out;
+
+	while (count > 0 && bit < SNAPSHOT_BLOCKS_PER_GROUP) {
+		if (!next3_set_bit_atomic(sb_bgl_lock(NEXT3_SB(sb),
+						block_group),
+					bit, exclude_bitmap_bh->b_data)) {
+			n++;
+			if (!exclude)
+				break;
+		} else if (n) {
+			snapshot_debug(2, "excluded blocks: [%d-%d/%ld]\n",
+					bit-n, bit-1, block_group);
+			excluded += n;
+			n = 0;
+		}
+		bit++;
+		count--;
+	}
+
+	if (n && !exclude) {
+		NEXT3_SET_FLAGS(sb, NEXT3_FLAGS_FIX_EXCLUDE);
+		next3_error(sb, where,
+			"snapshot file block [%d/%lu] not in exclude bitmap! - "
+			"running fsck to fix exclude bitmap is recommended.\n",
+			bit, block_group);
+		err = -EIO;
+		goto out;
+	}
+
+	if (n) {
+		snapshot_debug(2, "excluded blocks: [%d-%d/%ld]\n",
+				bit-n, bit-1, block_group);
+		excluded += n;
+	}
+
+	if (exclude && excluded) {
+		err = next3_journal_dirty_metadata(handle, exclude_bitmap_bh);
+		trace_cow_add(handle, excluded, excluded);
+	}
+out:
+	brelse(exclude_bitmap_bh);
+	return err ? err : excluded;
+}
 
 /*
  * COW functions
@@ -916,6 +1023,13 @@ test_pending_cow:
 cowed:
 	/* mark the buffer COWed in the current transaction */
 	next3_snapshot_mark_cowed(handle, bh);
+	if (clear) {
+		/* mark COWed block in exclude bitmap */
+		clear = next3_snapshot_exclude_blocks(handle, sb,
+				block, 1);
+		if (clear < 0)
+			err = clear;
+	}
 out:
 	brelse(sbh);
 	/* END COWing */
@@ -1019,6 +1133,10 @@ int next3_snapshot_test_and_move(const c
 	 * when they were mapped to snapshot file.
 	 */
 	vfs_dq_free_block(inode, count);
+	/* mark moved blocks in exclude bitmap */
+	excluded = next3_snapshot_exclude_blocks(handle, sb, block, count);
+	if (excluded < 0)
+		err = excluded;
 	trace_cow_add(handle, moved, count);
 out:
 	/* END moving */
@@ -1046,6 +1164,7 @@ int next3_snapshot_get_read_access(struc
 	unsigned long block_group = SNAPSHOT_BLOCK_GROUP(bh->b_blocknr);
 	next3_grpblk_t bit = SNAPSHOT_BLOCK_GROUP_OFFSET(bh->b_blocknr);
 	struct buffer_head *bitmap_bh;
+	struct buffer_head *exclude_bitmap_bh = NULL;
 	int err = 0;
 
 	if (PageReadahead(bh->b_page))
@@ -1063,7 +1182,16 @@ int next3_snapshot_get_read_access(struc
 		return -EIO;
 	}
 
+	exclude_bitmap_bh = read_exclude_bitmap(sb, block_group);
+	if (exclude_bitmap_bh &&
+		next3_test_bit(bit, exclude_bitmap_bh->b_data)) {
+		snapshot_debug(2, "warning: attempt to read through to "
+				"excluded block [%d/%lu] - read ahead?\n",
+				bit, block_group);
+		err = -EIO;
+	}
 
+	brelse(exclude_bitmap_bh);
 	brelse(bitmap_bh);
 	return err;
 }
diff -Nuarp a/fs/next3/snapshot_ctl.c b/fs/next3/snapshot_ctl.c
--- a/fs/next3/snapshot_ctl.c	2010-07-26 09:21:50.354736243 +0300
+++ b/fs/next3/snapshot_ctl.c	2010-07-26 09:21:49.754801051 +0300
@@ -719,6 +719,7 @@ int next3_snapshot_take(struct inode *in
 	struct next3_sb_info *sbi = NEXT3_SB(sb);
 	struct next3_super_block *es = NULL;
 	struct buffer_head *sbh = NULL;
+	struct buffer_head *exclude_bitmap_bh = NULL;
 	struct buffer_head *bhs[COPY_INODE_BLOCKS_NUM] = { NULL };
 	const char *mask = NULL;
 	struct inode *curr_inode;
@@ -860,6 +861,11 @@ copy_inode_blocks:
 	bhs[COPY_INODE_BITMAP] = sb_bread(sb,
 			le32_to_cpu(desc->bg_inode_bitmap));
 	bhs[COPY_INODE_TABLE] = iloc.bh;
+	brelse(exclude_bitmap_bh);
+	exclude_bitmap_bh = read_exclude_bitmap(sb, iloc.block_group);
+	if (exclude_bitmap_bh)
+		/* mask block bitmap with exclude bitmap */
+		mask = exclude_bitmap_bh->b_data;
 	err = -EIO;
 	for (i = 0; i < COPY_INODE_BLOCKS_NUM; i++) {
 		brelse(sbh);
@@ -930,6 +936,7 @@ out_unlockfs:
 	next3_snapshot_dump(5, inode);
 
 out_err:
+	brelse(exclude_bitmap_bh);
 	brelse(sbh);
 	for (i = 0; i < COPY_INODE_BLOCKS_NUM; i++)
 		brelse(bhs[i]);
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:21:50.364737762 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:21:49.764792112 +0300
@@ -311,6 +311,8 @@ static inline void exit_next3_snapshot(v
 /* balloc.c */
 extern struct buffer_head *read_block_bitmap(struct super_block *sb,
 					     unsigned int block_group);
+extern struct buffer_head *read_exclude_bitmap(struct super_block *sb,
+					       unsigned int block_group);
 
 /* namei.c */
 extern int next3_inode_list_add(handle_t *handle, struct inode *inode,
