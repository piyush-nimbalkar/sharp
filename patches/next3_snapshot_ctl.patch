==next3_snapshot_ctl.patch==

next3: snapshot control

Snapshot control with chattr -X.
Take/delete snapshot with chattr -X +/-S.
Enable/disable snapshot with chattr -X +/-n.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/ioctl.c b/fs/next3/ioctl.c
--- a/fs/next3/ioctl.c	2010-07-26 09:22:01.924913150 +0300
+++ b/fs/next3/ioctl.c	2010-07-26 09:22:01.404908944 +0300
@@ -33,6 +33,7 @@ long next3_ioctl(struct file *filp, unsi
 	switch (cmd) {
 	case NEXT3_IOC_GETFLAGS:
 		next3_get_inode_flags(ei);
+		next3_snapshot_get_flags(ei, filp);
 		flags = ei->i_flags & NEXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int __user *) arg);
 	case NEXT3_IOC_SETFLAGS: {
@@ -41,6 +42,7 @@ long next3_ioctl(struct file *filp, unsi
 		struct next3_iloc iloc;
 		unsigned int oldflags;
 		unsigned int jflag;
+		unsigned int snapflags = 0;
 
 		if (!is_owner_or_cap(inode))
 			return -EACCES;
@@ -61,6 +63,8 @@ long next3_ioctl(struct file *filp, unsi
 		if (IS_NOQUOTA(inode))
 			goto flags_out;
 
+		/* update snapshot 'open' flag under i_mutex */
+		next3_snapshot_get_flags(ei, filp);
 		oldflags = ei->i_flags;
 
 		/* The JOURNAL_DATA flag is modifiable only by root */
@@ -86,6 +90,35 @@ long next3_ioctl(struct file *filp, unsi
 				goto flags_out;
 		}
 
+		/*
+		 * Snapshot file flags can only be changed by
+		 * the relevant capability and under snapshot_mutex lock.
+		 */
+		snapflags = ((flags | oldflags) & NEXT3_FL_SNAPSHOT_MASK);
+		if (snapflags) {
+			if (!capable(CAP_SYS_RESOURCE)) {
+				/* indicate snapshot_mutex not taken */
+				snapflags = 0;
+				goto flags_out;
+			}
+
+			/*
+			 * snapshot_mutex should be held throughout the trio
+			 * snapshot_{set_flags,take,update}().  It must be taken
+			 * before starting the transaction, otherwise
+			 * journal_lock_updates() inside snapshot_take()
+			 * can deadlock:
+			 * A: journal_start()
+			 * A: snapshot_mutex_lock()
+			 * B: journal_start()
+			 * B: snapshot_mutex_lock() (waiting for A)
+			 * A: journal_stop()
+			 * A: snapshot_take() ->
+			 * A: 	journal_lock_updates() (waiting for B)
+			 */
+			mutex_lock(&NEXT3_SB(inode->i_sb)->s_snapshot_mutex);
+		}
+
 		handle = next3_journal_start(inode, 1);
 		if (IS_ERR(handle)) {
 			err = PTR_ERR(handle);
@@ -99,7 +132,9 @@ long next3_ioctl(struct file *filp, unsi
 
 		flags = flags & NEXT3_FL_USER_MODIFIABLE;
 		flags |= oldflags & ~NEXT3_FL_USER_MODIFIABLE;
-		ei->i_flags = flags;
+		err = next3_snapshot_set_flags(handle, inode, flags);
+		if (err)
+			goto flags_err;
 
 		next3_set_inode_flags(inode);
 		inode->i_ctime = CURRENT_TIME_SEC;
@@ -112,7 +147,25 @@ flags_err:
 
 		if ((jflag ^ oldflags) & (NEXT3_JOURNAL_DATA_FL))
 			err = next3_change_inode_journal_flag(inode, jflag);
+		if (err)
+			goto flags_out;
+
+		if ((flags | oldflags) & NEXT3_SNAPFILE_LIST_FL) {
+			/* clearing list flag - shrink/merge/remove snapshot */
+			int ret, cleanup = !(flags & NEXT3_SNAPFILE_LIST_FL);
+
+			if (!(oldflags & NEXT3_SNAPFILE_LIST_FL))
+				/* setting list flag - take snapshot */
+				err = next3_snapshot_take(inode);
+
+			/* update/cleanup snapshots list even if take failed */
+			ret = next3_snapshot_update(inode->i_sb, cleanup, 0);
+			if (!err)
+				err = ret;
+		}
 flags_out:
+		if (snapflags)
+			mutex_unlock(&NEXT3_SB(inode->i_sb)->s_snapshot_mutex);
 		mutex_unlock(&inode->i_mutex);
 		mnt_drop_write(filp->f_path.mnt);
 		return err;
@@ -242,12 +295,15 @@ setrsvsz_out:
 			err = -EFAULT;
 			goto group_extend_out;
 		}
+		/* avoid snapshot_take() in the middle of group_extend() */
+		mutex_lock(&NEXT3_SB(sb)->s_snapshot_mutex);
 		err = next3_group_extend(sb, NEXT3_SB(sb)->s_es, n_blocks_count);
 		journal_lock_updates(NEXT3_SB(sb)->s_journal);
 		err2 = journal_flush(NEXT3_SB(sb)->s_journal);
 		journal_unlock_updates(NEXT3_SB(sb)->s_journal);
 		if (err == 0)
 			err = err2;
+		mutex_unlock(&NEXT3_SB(sb)->s_snapshot_mutex);
 group_extend_out:
 		mnt_drop_write(filp->f_path.mnt);
 		return err;
@@ -270,12 +326,15 @@ group_extend_out:
 			goto group_add_out;
 		}
 
+		/* avoid snapshot_take() in the middle of group_add() */
+		mutex_lock(&NEXT3_SB(sb)->s_snapshot_mutex);
 		err = next3_group_add(sb, &input);
 		journal_lock_updates(NEXT3_SB(sb)->s_journal);
 		err2 = journal_flush(NEXT3_SB(sb)->s_journal);
 		journal_unlock_updates(NEXT3_SB(sb)->s_journal);
 		if (err == 0)
 			err = err2;
+		mutex_unlock(&NEXT3_SB(sb)->s_snapshot_mutex);
 group_add_out:
 		mnt_drop_write(filp->f_path.mnt);
 		return err;
diff -Nuarp a/fs/next3/snapshot_ctl.c b/fs/next3/snapshot_ctl.c
--- a/fs/next3/snapshot_ctl.c	2010-07-26 09:22:02.004914953 +0300
+++ b/fs/next3/snapshot_ctl.c	2010-07-26 09:22:01.484907006 +0300
@@ -110,6 +110,594 @@ static int next3_snapshot_reset_bitmap_c
 	return 0;
 }
 
+/*
+ * Snapshot control functions
+ *
+ * Snapshot files are controlled by changing snapshot flags with chattr and
+ * moving the snapshot file through the stages of its life cycle:
+ *
+ * 1. Creating a snapshot file
+ * The snapfile flag is changed for directories only (chattr +x), so
+ * snapshot files must be created inside a snapshots directory.
+ * They inherit the flag at birth and they die with it.
+ * This helps to avoid various race conditions when changing
+ * regular files to snapshots and back.
+ * Snapshot files are assigned with read-only address space operations, so
+ * they are not writable for users.
+ *
+ * 2. Taking a snapshot
+ * An empty snapshot file becomes the active snapshot after it is added to the
+ * head on the snapshots list by setting its snapshot list flag (chattr -X +S).
+ * snapshot_create() verifies that the file is empty and pre-allocates some
+ * blocks during the ioctl transaction.  snapshot_take() locks journal updates
+ * and copies some file system block to the pre-allocated blocks and then adds
+ * the snapshot file to the on-disk list and sets it as the active snapshot.
+ *
+ * 3. Mounting a snapshot
+ * A snapshot on the list can be enabled for user read access by setting the
+ * enabled flag (chattr -X +n) and disabled by clearing the enabled flag.
+ * An enabled snapshot can be mounted via a loop device and mounted as a
+ * read-only ext2 filesystem.
+ *
+ * 4. Deleting a snapshot
+ * A non-mounted and disabled snapshot may be marked for removal from the
+ * snapshots list by requesting to clear its snapshot list flag (chattr -X -S).
+ * The process of removing a snapshot from the list varies according to the
+ * dependencies between the snapshot and older snapshots on the list:
+ * - if all older snapshots are deleted, the snapshot is removed from the list.
+ * - if some older snapshots are enabled, snapshot_shrink() is called to free
+ *   unused blocks, but the snapshot remains on the list.
+ * - if all older snapshots are disabled, snapshot_merge() is called to move
+ *   used blocks to an older snapshot and the snapshot is removed from the list.
+ *
+ * 5. Unlinking a snapshot file
+ * When a snapshot file is no longer (or never was) on the snapshots list, it
+ * may be unlinked.  Snapshots on the list are protected from user unlink and
+ * truncate operations.
+ *
+ * 6. Discarding all snapshots
+ * An irregular way to abruptly end the lives of all snapshots on the list is by
+ * detaching the snapshot list head using the command: tune2fs -O ^has_snapshot.
+ * This action is applicable on an un-mounted next3 filesystem.  After mounting
+ * the filesystem, the discarded snapshot files will not be loaded, they will
+ * not have the snapshot list flag and therefore, may be unlinked.
+ */
+static int next3_snapshot_enable(struct inode *inode);
+static int next3_snapshot_disable(struct inode *inode);
+static int next3_snapshot_create(struct inode *inode);
+static int next3_snapshot_delete(struct inode *inode);
+
+/*
+ * next3_snapshot_get_flags() check snapshot state
+ * Called from next3_ioctl() under i_mutex
+ */
+void next3_snapshot_get_flags(struct next3_inode_info *ei, struct file *filp)
+{
+	int open_count = atomic_read(&filp->f_path.dentry->d_count);
+	/*
+	 * 1 count for ioctl (lsattr)
+	 * greater count means the snapshot is open by user (mounted?)
+	 */
+	if ((ei->i_flags & NEXT3_SNAPFILE_LIST_FL) && open_count > 1)
+		ei->i_flags |= NEXT3_SNAPFILE_OPEN_FL;
+	else
+		ei->i_flags &= ~NEXT3_SNAPFILE_OPEN_FL;
+}
+
+/*
+ * next3_snapshot_set_flags() monitors snapshot state changes
+ * Called from next3_ioctl() under i_mutex and snapshot_mutex
+ */
+int next3_snapshot_set_flags(handle_t *handle, struct inode *inode,
+			     unsigned int flags)
+{
+	unsigned int oldflags = NEXT3_I(inode)->i_flags;
+	int err = 0;
+
+	if (S_ISDIR(inode->i_mode)) {
+		/* only the snapfile flag may be set for directories */
+		NEXT3_I(inode)->i_flags &= ~NEXT3_SNAPFILE_FL;
+		NEXT3_I(inode)->i_flags |= flags & NEXT3_SNAPFILE_FL;
+		goto non_snapshot;
+	}
+
+	if (!next3_snapshot_file(inode)) {
+		if ((flags ^ oldflags) & ~NEXT3_FL_SNAPSHOT_MASK) {
+			/* snapflags can only be changed for snapfiles */
+			snapshot_debug(1, "changing snapflags for non snapfile"
+					" (ino=%lu) is not allowed\n",
+					inode->i_ino);
+			return -EINVAL;
+		}
+		goto non_snapshot;
+	}
+
+
+
+	if ((flags ^ oldflags) & NEXT3_SNAPFILE_ENABLED_FL) {
+		/* enabled/disabled the snapshot during transaction */
+		if (flags & NEXT3_SNAPFILE_ENABLED_FL)
+			err = next3_snapshot_enable(inode);
+		else
+			err = next3_snapshot_disable(inode);
+	}
+	if (err)
+		goto out;
+
+	if ((flags ^ oldflags) & NEXT3_SNAPFILE_LIST_FL) {
+		/* add/delete to snapshots list during transaction */
+		if (flags & NEXT3_SNAPFILE_LIST_FL)
+			err = next3_snapshot_create(inode);
+		else
+			err = next3_snapshot_delete(inode);
+	}
+	if (err)
+		goto out;
+
+	/* set snapshot user flags */
+	NEXT3_I(inode)->i_flags &= ~NEXT3_FL_SNAPSHOT_USER_MASK;
+	NEXT3_I(inode)->i_flags |= flags & NEXT3_FL_SNAPSHOT_USER_MASK;
+non_snapshot:
+	/* set only non-snapshot flags here */
+	flags &= ~NEXT3_FL_SNAPSHOT_MASK;
+	flags |= (NEXT3_I(inode)->i_flags & NEXT3_FL_SNAPSHOT_MASK);
+	NEXT3_I(inode)->i_flags = flags;
+
+out:
+	/*
+	 * retake reserve inode write from next3_ioctl() and mark inode
+	 * dirty
+	 */
+	if (!err)
+		err = next3_mark_inode_dirty(handle, inode);
+	return err;
+}
+
+/*
+ * If we have fewer than nblocks credits,
+ * extend transaction by a minimum of NEXT3_MAX_TRANS_DATA.
+ * If that fails, restart the transaction &
+ * regain write access for the inode block.
+ */
+static int __extend_or_restart_transaction(const char *where,
+		handle_t *handle, struct inode *inode, int nblocks)
+{
+	int err;
+
+	if (NEXT3_SNAPSHOT_HAS_TRANS_BLOCKS(handle, nblocks))
+		return 0;
+
+	if (nblocks < NEXT3_MAX_TRANS_DATA)
+		nblocks = NEXT3_MAX_TRANS_DATA;
+
+	err = __next3_journal_extend(where,
+			(next3_handle_t *)handle, nblocks);
+	if (err < 0)
+		return err;
+	if (err) {
+		if (inode) {
+			/* lazy way to do mark_iloc_dirty() */
+			err = next3_mark_inode_dirty(handle, inode);
+			if (err)
+				return err;
+		}
+		err = __next3_journal_restart(where,
+				(next3_handle_t *)handle, nblocks);
+		if (err)
+			return err;
+		if (inode)
+			/* lazy way to do reserve_inode_write() */
+			err = next3_mark_inode_dirty(handle, inode);
+	}
+
+	return err;
+}
+
+#define extend_or_restart_transaction(handle, nblocks)			\
+	__extend_or_restart_transaction(__func__, (handle), NULL, (nblocks))
+#define extend_or_restart_transaction_inode(handle, inode, nblocks)	\
+	__extend_or_restart_transaction(__func__, (handle), (inode), (nblocks))
+
+
+/*
+ * next3_snapshot_create() initializes a snapshot file
+ * and adds it to the list of snapshots
+ * Called under i_mutex and snapshot_mutex
+ */
+static int next3_snapshot_create(struct inode *inode)
+{
+	handle_t *handle;
+	struct super_block *sb = inode->i_sb;
+	struct next3_sb_info *sbi = NEXT3_SB(sb);
+	struct inode *active_snapshot = next3_snapshot_has_active(sb);
+	struct next3_inode_info *ei = NEXT3_I(inode);
+	int i, err, ret;
+	loff_t snapshot_blocks = le32_to_cpu(sbi->s_es->s_blocks_count);
+	if (active_snapshot) {
+		snapshot_debug(1, "failed to add snapshot because active "
+			       "snapshot (%u) has to be deleted first\n",
+			       active_snapshot->i_generation);
+		return -EINVAL;
+	}
+
+	/* prevent take of unlinked snapshot file */
+	if (!inode->i_nlink) {
+		snapshot_debug(1, "failed to create snapshot file (ino=%lu) "
+				"because it has 0 nlink count\n",
+				inode->i_ino);
+		return -EINVAL;
+	}
+
+	/* prevent recycling of old snapshot files */
+	if ((ei->i_flags & NEXT3_FL_SNAPSHOT_MASK) != NEXT3_SNAPFILE_FL) {
+		snapshot_debug(1, "failed to create snapshot file (ino=%lu) "
+				"because it has snapshot flags (0x%x)\n",
+				inode->i_ino,
+				inode->i_flags & NEXT3_FL_SNAPSHOT_MASK);
+		return -EINVAL;
+	}
+
+	/* verify that no inode blocks are allocated */
+	for (i = 0; i < NEXT3_N_BLOCKS; i++) {
+		if (ei->i_data[i])
+			break;
+	}
+	/* Don't need i_size_read because we hold i_mutex */
+	if (i != NEXT3_N_BLOCKS ||
+		inode->i_size > 0 || ei->i_disksize > 0) {
+		snapshot_debug(1, "failed to create snapshot file (ino=%lu) "
+				"because it is not empty (i_data[%d]=%u, "
+				"i_size=%lld, i_disksize=%lld)\n",
+				inode->i_ino, i, ei->i_data[i],
+				inode->i_size, ei->i_disksize);
+		return -EINVAL;
+	}
+
+	/*
+	 * Take a reference to the small transaction that started in
+	 * next3_ioctl() We will extend or restart this transaction as we go
+	 * along.  journal_start(n > 1) would not have increase the buffer
+	 * credits.
+	 */
+	handle = next3_journal_start(inode, 1);
+
+	err = extend_or_restart_transaction_inode(handle, inode, 2);
+	if (err)
+		goto out_handle;
+
+	/* record the new snapshot ID in the snapshot inode generation field */
+	inode->i_generation = le32_to_cpu(sbi->s_es->s_snapshot_id) + 1;
+	if (inode->i_generation == 0)
+		/* 0 is not a valid snapshot id */
+		inode->i_generation = 1;
+
+	/* record the file system size in the snapshot inode disksize field */
+	SNAPSHOT_SET_SIZE(inode, snapshot_blocks << SNAPSHOT_BLOCK_SIZE_BITS);
+	SNAPSHOT_SET_DISABLED(inode);
+
+	if (!NEXT3_HAS_RO_COMPAT_FEATURE(sb,
+		NEXT3_FEATURE_RO_COMPAT_HAS_SNAPSHOT))
+		/* set the 'has_snapshot' feature */
+		NEXT3_SET_RO_COMPAT_FEATURE(sb,
+			NEXT3_FEATURE_RO_COMPAT_HAS_SNAPSHOT);
+
+	lock_super(sb);
+	err = next3_journal_get_write_access(handle, sbi->s_sbh);
+	sbi->s_es->s_snapshot_list = inode->i_ino;
+	if (!err)
+		err = next3_journal_dirty_metadata(handle, sbi->s_sbh);
+	unlock_super(sb);
+	if (err)
+		goto out_handle;
+
+	err = next3_mark_inode_dirty(handle, inode);
+	if (err)
+		goto out_handle;
+
+
+	snapshot_debug(1, "snapshot (%u) created\n", inode->i_generation);
+	err = 0;
+out_handle:
+	ret = next3_journal_stop(handle);
+	if (!err)
+		err = ret;
+	return err;
+}
+
+/*
+ * If we call next3_getblk() with NULL handle we will get read through access
+ * to snapshot inode.  We don't want read through access in snapshot_take(),
+ * so we call next3_getblk() with this dummy handle and since we are not
+ * allocating snapshot block here the handle will not be used anyway.
+ */
+static handle_t dummy_handle;
+
+
+/*
+ * next3_snapshot_take() makes a new snapshot file
+ * into the active snapshot
+ *
+ * this function calls journal_lock_updates()
+ * and should not be called during a journal transaction
+ * Called from next3_ioctl() under i_mutex and snapshot_mutex
+ */
+int next3_snapshot_take(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct next3_sb_info *sbi = NEXT3_SB(sb);
+	struct next3_super_block *es = NULL;
+	struct buffer_head *sbh = NULL;
+	int err = -EIO;
+
+	if (!sbi->s_sbh)
+		goto out_err;
+	else if (sbi->s_sbh->b_blocknr != 0) {
+		snapshot_debug(1, "warning: unexpected super block at block "
+			"(%lld:%d)!\n", (long long)sbi->s_sbh->b_blocknr,
+			(int)((char *)sbi->s_es - (char *)sbi->s_sbh->b_data));
+	} else if (sbi->s_es->s_magic != cpu_to_le16(NEXT3_SUPER_MAGIC)) {
+		snapshot_debug(1, "warning: super block of snapshot (%u) is "
+			       "broken!\n", inode->i_generation);
+	} else
+		sbh = next3_getblk(&dummy_handle, inode, SNAPSHOT_IBLOCK(0),
+				   SNAPMAP_READ, &err);
+
+	if (!sbh || sbh->b_blocknr == 0) {
+		snapshot_debug(1, "warning: super block of snapshot (%u) not "
+			       "allocated\n", inode->i_generation);
+		goto out_err;
+	} else {
+		snapshot_debug(4, "super block of snapshot (%u) mapped to "
+			       "block (%lld)\n", inode->i_generation,
+			       (long long)sbh->b_blocknr);
+		es = (struct next3_super_block *)(sbh->b_data +
+						  ((char *)sbi->s_es -
+						   sbi->s_sbh->b_data));
+	}
+
+	err = -EIO;
+
+	/*
+	 * flush journal to disk and clear the RECOVER flag
+	 * before taking the snapshot
+	 */
+	sb->s_op->freeze_fs(sb);
+	lock_super(sb);
+
+#ifdef CONFIG_NEXT3_FS_DEBUG
+	if (snapshot_enable_test[SNAPTEST_TAKE]) {
+		snapshot_debug(1, "taking snapshot (%u) ...\n",
+				inode->i_generation);
+		/* sleep 1 tunable delay unit */
+		snapshot_test_delay(SNAPTEST_TAKE);
+	}
+#endif
+
+
+	/* reset COW bitmap cache */
+	err = next3_snapshot_reset_bitmap_cache(sb, 0);
+	if (err)
+		goto out_unlockfs;
+	/* set as in-memory active snapshot */
+	err = next3_snapshot_set_active(sb, inode);
+	if (err)
+		goto out_unlockfs;
+
+	/* set as on-disk active snapshot */
+	sbi->s_es->s_snapshot_id =
+		cpu_to_le32(le32_to_cpu(sbi->s_es->s_snapshot_id)+1);
+	if (sbi->s_es->s_snapshot_id == 0)
+		/* 0 is not a valid snapshot id */
+		sbi->s_es->s_snapshot_id = cpu_to_le32(1);
+	sbi->s_es->s_snapshot_inum = inode->i_ino;
+
+	err = 0;
+out_unlockfs:
+	unlock_super(sb);
+	sb->s_op->unfreeze_fs(sb);
+
+	if (err)
+		goto out_err;
+
+	snapshot_debug(1, "snapshot (%u) has been taken\n",
+			inode->i_generation);
+
+out_err:
+	brelse(sbh);
+	return err;
+}
+
+
+/*
+ * next3_snapshot_enable() enables snapshot mount
+ * sets the in-use flag and the active snapshot
+ * Called under i_mutex and snapshot_mutex
+ */
+static int next3_snapshot_enable(struct inode *inode)
+{
+	struct next3_inode_info *ei = NEXT3_I(inode);
+
+	if (!next3_snapshot_list(inode)) {
+		snapshot_debug(1, "next3_snapshot_enable() called with "
+			       "snapshot file (ino=%lu) not on list\n",
+			       inode->i_ino);
+		return -EINVAL;
+	}
+
+	if (ei->i_flags & NEXT3_SNAPFILE_DELETED_FL) {
+		snapshot_debug(1, "enable of deleted snapshot (%u) "
+				"is not permitted\n",
+				inode->i_generation);
+		return -EPERM;
+	}
+
+	/*
+	 * set i_size to block device size to enable loop device mount
+	 */
+	SNAPSHOT_SET_ENABLED(inode);
+	ei->i_flags |= NEXT3_SNAPFILE_ENABLED_FL;
+
+	/* Don't need i_size_read because we hold i_mutex */
+	snapshot_debug(4, "setting snapshot (%u) i_size to (%lld)\n",
+			inode->i_generation, inode->i_size);
+	snapshot_debug(1, "snapshot (%u) enabled\n", inode->i_generation);
+	return 0;
+}
+
+/*
+ * next3_snapshot_disable() disables snapshot mount
+ * Called under i_mutex and snapshot_mutex
+ */
+static int next3_snapshot_disable(struct inode *inode)
+{
+	struct next3_inode_info *ei = NEXT3_I(inode);
+
+	if (!next3_snapshot_list(inode)) {
+		snapshot_debug(1, "next3_snapshot_disable() called with "
+			       "snapshot file (ino=%lu) not on list\n",
+			       inode->i_ino);
+		return -EINVAL;
+	}
+
+	if (ei->i_flags & NEXT3_SNAPFILE_OPEN_FL) {
+		snapshot_debug(1, "disable of mounted snapshot (%u) "
+				"is not permitted\n",
+				inode->i_generation);
+		return -EPERM;
+	}
+
+	/*
+	 * set i_size to zero to disable loop device mount
+	 */
+	SNAPSHOT_SET_DISABLED(inode);
+	ei->i_flags &= ~NEXT3_SNAPFILE_ENABLED_FL;
+
+	/* invalidate page cache */
+	truncate_inode_pages(&inode->i_data, SNAPSHOT_BYTES_OFFSET);
+
+	/* Don't need i_size_read because we hold i_mutex */
+	snapshot_debug(4, "setting snapshot (%u) i_size to (%lld)\n",
+			inode->i_generation, inode->i_size);
+	snapshot_debug(1, "snapshot (%u) disabled\n", inode->i_generation);
+	return 0;
+}
+
+/*
+ * next3_snapshot_delete() marks snapshot for deletion
+ * Called under i_mutex and snapshot_mutex
+ */
+static int next3_snapshot_delete(struct inode *inode)
+{
+	struct next3_inode_info *ei = NEXT3_I(inode);
+
+	if (!next3_snapshot_list(inode)) {
+		snapshot_debug(1, "next3_snapshot_delete() called with "
+			       "snapshot file (ino=%lu) not on list\n",
+			       inode->i_ino);
+		return -EINVAL;
+	}
+
+	if (ei->i_flags & NEXT3_SNAPFILE_ENABLED_FL) {
+		snapshot_debug(1, "delete of enabled snapshot (%u) "
+				"is not permitted\n",
+				inode->i_generation);
+		return -EPERM;
+	}
+
+	/* mark deleted for later cleanup to finish the job */
+	ei->i_flags |= NEXT3_SNAPFILE_DELETED_FL;
+	snapshot_debug(1, "snapshot (%u) marked for deletion\n",
+			inode->i_generation);
+	return 0;
+}
+
+/*
+ * next3_snapshot_remove - removes a snapshot from the list
+ * @inode: snapshot inode
+ *
+ * Removed the snapshot inode from in-memory and on-disk snapshots list of
+ * and truncates the snapshot inode.
+ * Called from next3_snapshot_update/cleanup/merge() under snapshot_mutex.
+ * Returns 0 on success and <0 on error.
+ */
+static int next3_snapshot_remove(struct inode *inode)
+{
+	handle_t *handle;
+	struct next3_sb_info *sbi;
+	struct next3_inode_info *ei = NEXT3_I(inode);
+	int err = 0, ret;
+
+	/* elevate ref count until final cleanup */
+	if (!igrab(inode))
+		return -EIO;
+
+	if (ei->i_flags & (NEXT3_SNAPFILE_ENABLED_FL | NEXT3_SNAPFILE_INUSE_FL
+			   | NEXT3_SNAPFILE_ACTIVE_FL)) {
+		snapshot_debug(4, "deferred delete of %s snapshot (%u)\n",
+				(ei->i_flags & NEXT3_SNAPFILE_ACTIVE_FL) ?
+				"active" :
+				((ei->i_flags & NEXT3_SNAPFILE_ENABLED_FL) ?
+				"enabled" : "referenced"),
+			       inode->i_generation);
+		goto out_err;
+	}
+
+	/* start large truncate transaction that will be extended/restarted */
+	handle = next3_journal_start(inode, NEXT3_MAX_TRANS_DATA);
+	if (IS_ERR(handle)) {
+		err = PTR_ERR(handle);
+		goto out_err;
+	}
+	sbi = NEXT3_SB(inode->i_sb);
+
+
+	err = extend_or_restart_transaction_inode(handle, inode, 2);
+	if (err)
+		goto out_handle;
+
+	lock_super(inode->i_sb);
+	err = next3_journal_get_write_access(handle, sbi->s_sbh);
+	sbi->s_es->s_snapshot_list = 0;
+	if (!err)
+		err = next3_journal_dirty_metadata(handle, sbi->s_sbh);
+	unlock_super(inode->i_sb);
+	if (err)
+		goto out_handle;
+	/*
+	 * At this point, this snapshot is empty and not on the snapshots list.
+	 * As long as it was on the list it had to have the LIST flag to prevent
+	 * truncate/unlink.  Now that it is removed from the list, the LIST flag
+	 * and other snapshot status flags should be cleared.  It will still
+	 * have the SNAPFILE and DELETED flag to indicate this is a deleted
+	 * snapshot that should not be recycled.  There is no need to mark the
+	 * inode dirty, because the 'dynamic' status flags are not persistent.
+	 */
+	ei->i_flags &= ~NEXT3_FL_SNAPSHOT_DYN_MASK;
+
+out_handle:
+	ret = next3_journal_stop(handle);
+	if (!err)
+		err = ret;
+	if (err)
+		goto out_err;
+
+	/* sleep 1 tunable delay unit */
+	snapshot_test_delay(SNAPTEST_DELETE);
+	snapshot_debug(1, "snapshot (%u) deleted\n", inode->i_generation);
+
+	err = 0;
+out_err:
+	/* drop final ref count - taken on entry to this function */
+	iput(inode);
+	if (err) {
+		snapshot_debug(1, "failed to delete snapshot (%u)\n",
+				inode->i_generation);
+	}
+	return err;
+}
+
+
+
 
 /*
  * Snapshot constructor/destructor
@@ -307,6 +895,8 @@ void next3_snapshot_destroy(struct super
 int next3_snapshot_update(struct super_block *sb, int cleanup, int read_only)
 {
 	struct inode *active_snapshot = next3_snapshot_has_active(sb);
+	struct inode *used_by = NULL; /* last non-deleted snapshot found */
+	int deleted;
 	int err = 0;
 
 	BUG_ON(read_only && cleanup);
@@ -315,5 +905,25 @@ int next3_snapshot_update(struct super_b
 			NEXT3_SNAPFILE_ACTIVE_FL|NEXT3_SNAPFILE_LIST_FL;
 
 
+	if (!active_snapshot || !cleanup || used_by)
+		return 0;
+
+	/* if all snapshots are deleted - deactivate active snapshot */
+	deleted = NEXT3_I(active_snapshot)->i_flags & NEXT3_SNAPFILE_DELETED_FL;
+	if (deleted && igrab(active_snapshot)) {
+		/* lock journal updates before deactivating snapshot */
+		sb->s_op->freeze_fs(sb);
+		lock_super(sb);
+		/* deactivate in-memory active snapshot - cannot fail */
+		(void) next3_snapshot_set_active(sb, NULL);
+		/* clear on-disk active snapshot */
+		NEXT3_SB(sb)->s_es->s_snapshot_inum = 0;
+		unlock_super(sb);
+		sb->s_op->unfreeze_fs(sb);
+		/* remove unused deleted active snapshot */
+		err = next3_snapshot_remove(active_snapshot);
+		/* drop the refcount to 0 */
+		iput(active_snapshot);
+	}
 	return err;
 }
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:02.014913251 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:01.494946260 +0300
@@ -92,6 +92,15 @@ enum next3_bh_state_bits {
 
 BUFFER_FNS(Partial_Write, partial_write)
 
+/*
+ * Snapshot control functions
+ */
+extern void next3_snapshot_get_flags(struct next3_inode_info *ei,
+				     struct file *filp);
+extern int next3_snapshot_set_flags(handle_t *handle, struct inode *inode,
+				    unsigned int flags);
+extern int next3_snapshot_take(struct inode *inode);
+
 
 /*
  * snapshot_map_blocks() command flags passed to get_blocks_handle() on its
