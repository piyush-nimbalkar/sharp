===next3_snapshot_journal_release.patch===

next3: snapshot journaled - implement journal_release_buffer()

The API journal_release_buffer() is called to cancel a previous call
to journal_get_write_access() and to recall the used buffer credit.
Current implementation of journal_release_buffer() in JBD is empty,
since no buffer credits are used until the buffer is marked dirty.
However, since the resulting snapshot COW operation cannot be undone,
we try to extend the current transaction to compensate for the used
credits of the extra COW operation, so we don't run out of buffer
credits too soon.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/balloc.c b/fs/next3/balloc.c
--- a/fs/next3/balloc.c	2010-07-26 09:21:57.614849147 +0300
+++ b/fs/next3/balloc.c	2010-07-26 09:21:57.054836573 +0300
@@ -1440,7 +1440,12 @@ out:
 	}
 
 	BUFFER_TRACE(bitmap_bh, "journal_release_buffer");
-	next3_journal_release_buffer(handle, bitmap_bh);
+	if (!fatal)
+		fatal = next3_journal_release_buffer(handle, bitmap_bh);
+	if (fatal) {
+		*errp = fatal;
+		return -1;
+	}
 	return ret;
 }
 
diff -Nuarp a/fs/next3/ialloc.c b/fs/next3/ialloc.c
--- a/fs/next3/ialloc.c	2010-07-26 09:21:57.624912226 +0300
+++ b/fs/next3/ialloc.c	2010-07-26 09:21:57.064839969 +0300
@@ -492,7 +492,9 @@ repeat_in_this_group:
 				goto got;
 			}
 			/* we lost it */
-			journal_release_buffer(handle, bitmap_bh);
+			err = next3_journal_release_buffer(handle, bitmap_bh);
+			if (err)
+				goto fail;
 
 			if (++ino < NEXT3_INODES_PER_GROUP(sb))
 				goto repeat_in_this_group;
diff -Nuarp a/fs/next3/next3_jbd.c b/fs/next3/next3_jbd.c
--- a/fs/next3/next3_jbd.c	2010-07-26 09:21:57.654849042 +0300
+++ b/fs/next3/next3_jbd.c	2010-07-26 09:21:57.094839166 +0300
@@ -87,3 +87,34 @@ int __next3_journal_dirty_metadata(const
 	}
 	return err;
 }
+int __next3_journal_release_buffer(const char *where, handle_t *handle,
+				struct buffer_head *bh)
+{
+	int err = 0;
+
+	if (IS_COWING(handle))
+		goto out;
+
+	/*
+	 * Trying to cancel a previous call to get_write_access(), which may
+	 * have resulted in a single COW operation.  We don't need to add
+	 * user credits, but if COW credits are too low we will try to
+	 * extend the transaction to compensate for the buffer credits used
+	 * by the extra COW operation.
+	 */
+	err = next3_journal_extend(handle, 0);
+	if (err > 0) {
+		/* well, we can't say we didn't try - now lets hope
+		 * we have enough buffer credits to spare */
+		snapshot_debug(1, "%s: warning: couldn't extend transaction "
+				"from %s (credits=%d/%d)\n", __func__,
+				where, handle->h_buffer_credits,
+				((next3_handle_t *)handle)->h_user_credits);
+		err = 0;
+	}
+	next3_journal_trace(SNAP_WARN, where, handle, -1);
+out:
+	journal_release_buffer(handle, bh);
+	return err;
+}
+
diff -Nuarp a/fs/next3/next3_jbd.h b/fs/next3/next3_jbd.h
--- a/fs/next3/next3_jbd.h	2010-07-26 09:21:57.704915695 +0300
+++ b/fs/next3/next3_jbd.h	2010-07-26 09:21:57.144908406 +0300
@@ -215,11 +215,12 @@ int next3_mark_inode_dirty(handle_t *han
  * been done yet.
  */
 
-static inline void next3_journal_release_buffer(handle_t *handle,
-						struct buffer_head *bh)
-{
-	journal_release_buffer(handle, bh);
-}
+int __next3_journal_release_buffer(const char *where, handle_t *handle,
+				struct buffer_head *bh);
+
+#define next3_journal_release_buffer(handle, bh) \
+	__next3_journal_release_buffer(__func__, (handle), (bh))
+
 
 void next3_journal_abort_handle(const char *caller, const char *err_fn,
 		struct buffer_head *bh, handle_t *handle, int err);
diff -Nuarp a/fs/next3/xattr.c b/fs/next3/xattr.c
--- a/fs/next3/xattr.c	2010-07-26 09:21:57.684849418 +0300
+++ b/fs/next3/xattr.c	2010-07-26 09:21:57.124840370 +0300
@@ -722,7 +722,9 @@ next3_xattr_block_set(handle_t *handle, 
 			int offset = (char *)s->here - bs->bh->b_data;
 
 			unlock_buffer(bs->bh);
-			journal_release_buffer(handle, bs->bh);
+			error = next3_journal_release_buffer(handle, bs->bh);
+			if (error)
+				goto cleanup;
 
 			if (ce) {
 				mb_cache_entry_release(ce);
