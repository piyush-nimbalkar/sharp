===next3_snapshot_block_move.patch===

next3: snapshot block operation - move blocks to snapshot

Implementation of moving blocks into a snapshot file.
The move block command maps an allocated blocks to the snapshot file,
allocating only the indirect blocks when needed.
This mechanism is used to move-on-write data blocks to snapshot.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:22:02.944929508 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:22:02.434920472 +0300
@@ -563,6 +563,11 @@ static int next3_alloc_blocks(handle_t *
 			count--;
 		}
 
+		if (blks == 0 && target == 0) {
+			/* mapping data blocks */
+			*err = 0;
+			return 0;
+		}
 		if (count > 0)
 			break;
 	}
@@ -605,9 +610,10 @@ failed_out:
  *	next3_alloc_block() (normally -ENOSPC). Otherwise we set the chain
  *	as described above and return 0.
  */
-static int next3_alloc_branch(handle_t *handle, struct inode *inode,
-			int indirect_blks, int *blks, next3_fsblk_t goal,
-			int *offsets, Indirect *branch)
+static int next3_alloc_branch_cow(handle_t *handle, struct inode *inode,
+			next3_fsblk_t iblock, int indirect_blks,
+				  int *blks, next3_fsblk_t goal,
+				  int *offsets, Indirect *branch, int cmd)
 {
 	int blocksize = inode->i_sb->s_blocksize;
 	int i, n = 0;
@@ -617,6 +623,25 @@ static int next3_alloc_branch(handle_t *
 	next3_fsblk_t new_blocks[4];
 	next3_fsblk_t current_block;
 
+	if (SNAPMAP_ISMOVE(cmd)) {
+		/* mapping snapshot block to block device block */
+		current_block = SNAPSHOT_BLOCK(iblock);
+		num = 0;
+		if (indirect_blks > 0) {
+			/* allocating only indirect blocks */
+			next3_alloc_blocks(handle, inode, goal, indirect_blks,
+					0, new_blocks, &err);
+			if (err)
+				return err;
+		}
+		/* charge snapshot file owner for moved blocks */
+		if (vfs_dq_alloc_block(inode, *blks)) {
+			err = -EDQUOT;
+			goto failed;
+		}
+		num = *blks;
+		new_blocks[indirect_blks] = current_block;
+	} else
 	num = next3_alloc_blocks(handle, inode, goal, indirect_blks,
 				*blks, new_blocks, &err);
 	if (err)
@@ -677,7 +702,11 @@ failed:
 	for (i = 0; i <indirect_blks; i++)
 		next3_free_blocks(handle, inode, new_blocks[i], 1);
 
-	next3_free_blocks(handle, inode, new_blocks[i], num);
+	if (SNAPMAP_ISMOVE(cmd) && num > 0)
+		/* don't charge snapshot file owner if move failed */
+		vfs_dq_free_block(inode, num);
+	else if (num > 0)
+		next3_free_blocks(handle, inode, new_blocks[i], num);
 
 	return err;
 }
@@ -696,8 +725,8 @@ failed:
  * inode (->i_blocks, etc.). In case of success we end up with the full
  * chain to new block and return 0.
  */
-static int next3_splice_branch(handle_t *handle, struct inode *inode,
-			long block, Indirect *where, int num, int blks)
+static int next3_splice_branch_cow(handle_t *handle, struct inode *inode,
+			long block, Indirect *where, int num, int blks, int cmd)
 {
 	int i;
 	int err = 0;
@@ -736,6 +765,9 @@ static int next3_splice_branch(handle_t 
 	 * in i_block_alloc_info, to assist find the proper goal block for next
 	 * allocation
 	 */
+	if (SNAPMAP_ISMOVE(cmd))
+		/* don't update i_block_alloc_info with moved block */
+		block_i = NULL;
 	if (block_i) {
 		block_i->last_alloc_logical_block = block + blks - 1;
 		block_i->last_alloc_physical_block =
@@ -777,7 +809,12 @@ err_out:
 		next3_journal_forget(handle, where[i].bh);
 		next3_free_blocks(handle,inode,le32_to_cpu(where[i-1].key),1);
 	}
-	next3_free_blocks(handle, inode, le32_to_cpu(where[num].key), blks);
+	if (SNAPMAP_ISMOVE(cmd))
+		/* don't charge snapshot file owner if move failed */
+		vfs_dq_free_block(inode, blks);
+	else
+		next3_free_blocks(handle, inode, le32_to_cpu(where[num].key),
+				  blks);
 
 	return err;
 }
@@ -994,8 +1031,9 @@ int next3_get_blocks_handle(handle_t *ha
 	/*
 	 * Block out next3_truncate while we alter the tree
 	 */
-	err = next3_alloc_branch(handle, inode, indirect_blks, &count, goal,
-				offsets + (partial - chain), partial);
+	err = next3_alloc_branch_cow(handle, inode, iblock, indirect_blks,
+				     &count, goal, offsets + (partial - chain),
+				     partial, create);
 	if (err)
 		goto out_mutex;
 
@@ -1044,8 +1082,8 @@ int next3_get_blocks_handle(handle_t *ha
 	 * may need to return -EAGAIN upwards in the worst case.  --sct
 	 */
 	if (!err)
-		err = next3_splice_branch(handle, inode, iblock,
-					partial, indirect_blks, count);
+		err = next3_splice_branch_cow(handle, inode, iblock, partial,
+					      indirect_blks, count, create);
 out_mutex:
 	mutex_unlock(&ei->truncate_mutex);
 	if (err)
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:22:03.025001090 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:22:02.514921841 +0300
@@ -12,6 +12,7 @@
  * Next3 snapshots core functions.
  */
 
+#include <linux/quotaops.h>
 #include "snapshot.h"
 
 #define snapshot_debug_hl(n, f, a...)	snapshot_debug_l(n, handle ? 	\
@@ -400,3 +401,102 @@ out:
 	return err;
 }
 
+/*
+ * next3_snapshot_test_and_move - move blocks to active snapshot
+ * @where:	name of caller function
+ * @handle:	JBD handle
+ * @inode:	owner of blocks (NULL for global metadata blocks)
+ * @block:	address of first block to move
+ * @maxblocks:	max. blocks to move
+ * @move:	if false, only test if @block needs to be moved
+ *
+ * Return values:
+ * > 0 - no. of blocks that were (or needs to be) moved to snapshot
+ * = 0 - @block doesn't need to be moved
+ * < 0 - error
+ */
+int next3_snapshot_test_and_move(const char *where, handle_t *handle,
+	struct inode *inode, next3_fsblk_t block, int maxblocks, int move)
+{
+	struct super_block *sb = handle->h_transaction->t_journal->j_private;
+	struct inode *active_snapshot = next3_snapshot_has_active(sb);
+	next3_fsblk_t blk = 0;
+	int err = 0, count = maxblocks;
+	int excluded = 0;
+
+	if (!active_snapshot)
+		/* no active snapshot - no need to move */
+		return 0;
+
+	next3_snapshot_trace_cow(where, handle, sb, inode, NULL, block, move);
+
+	BUG_ON(IS_COWING(handle) || inode == active_snapshot);
+
+	/* BEGIN moving */
+	next3_snapshot_cow_begin(handle);
+
+	if (inode)
+		excluded = next3_snapshot_excluded(inode);
+	if (excluded) {
+		/* don't move excluded file block to snapshot */
+		snapshot_debug_hl(4, "file (%lu) excluded from snapshot\n",
+				inode->i_ino);
+		move = 0;
+	}
+
+	if (excluded)
+		goto out;
+	if (!err) {
+		/* block not in COW bitmap - no need to move */
+		trace_cow_inc(handle, ok_bitmap);
+		goto out;
+	}
+
+	if (inode == NULL) {
+		/*
+		 * This is next3_group_extend() "freeing" the blocks that
+		 * were added to the block group.  These block should not be
+		 * moved to snapshot.
+		 */
+		trace_cow_inc(handle, ok_bitmap);
+		err = 0;
+		goto out;
+	}
+
+	/* count blocks are in use by snapshot - check if @block is mapped */
+	err = next3_snapshot_map_blocks(handle, active_snapshot, block, 1, &blk,
+					SNAPMAP_READ);
+	if (err < 0)
+		goto out;
+	if (err > 0) {
+		/* block already mapped in snapshot - no need to move */
+		trace_cow_inc(handle, ok_mapped);
+		err = 0;
+		goto out;
+	}
+
+	/* @count blocks need to be moved */
+	err = count;
+	if (!move)
+		/* don't move - we were just checking */
+		goto out;
+
+	/* try to move @count blocks from inode to snapshot */
+	err = next3_snapshot_map_blocks(handle, active_snapshot, block,
+			count, NULL, SNAPMAP_MOVE);
+	if (err <= 0)
+		goto out;
+	count = err;
+	/*
+	 * User should no longer be charged for these blocks.
+	 * Snapshot file owner was charged for these blocks
+	 * when they were mapped to snapshot file.
+	 */
+	vfs_dq_free_block(inode, count);
+	trace_cow_add(handle, moved, count);
+out:
+	/* END moving */
+	next3_snapshot_cow_end(where, handle, block, err);
+	return err;
+}
+
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:03.044996705 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:02.524921073 +0300
@@ -147,7 +147,17 @@ extern int next3_snapshot_test_and_cow(c
 	next3_snapshot_test_and_cow(__func__, handle, inode,	\
 			bh, cow)
 
-#define next3_snapshot_move(handle, inode, block, num, move) (num)
+extern int next3_snapshot_test_and_move(const char *where,
+		handle_t *handle, struct inode *inode,
+		next3_fsblk_t block, int maxblocks, int move);
+
+/*
+ * test if blocks should be moved to snapshot
+ * and if they should, try to move them to the active snapshot
+ */
+#define next3_snapshot_move(handle, inode, block, num, move)	\
+	next3_snapshot_test_and_move(__func__, handle, inode,	\
+			block, num, move)
 
 /*
  * Block access functions
