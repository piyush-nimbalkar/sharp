===next3_snapshot_race_bitmap.patch===

next3: snapshot race conditions - concurrent COW bitmap operations

Wait for pending COW bitmap creations to complete.
When concurrent tasks try to COW buffers from the same block group
for the first time, the first task to reset the COW bitmap cache
is elected to create the new COW bitmap block.  The rest of the tasks
wait (in msleep(1) loop), until the COW bitmap cache is uptodate.
The COWing task copies the bitmap block into the new COW bitmap block
and updates the COW bitmap cache with the new block number.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:21:53.814827895 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:21:53.234863161 +0300
@@ -385,6 +385,7 @@ next3_snapshot_read_cow_bitmap(handle_t 
 	next3_fsblk_t bitmap_blk;
 	next3_fsblk_t cow_bitmap_blk;
 	int err = 0;
+	SNAPSHOT_DEBUG_ONCE;
 
 	desc = next3_get_group_desc(sb, block_group, NULL);
 	if (!desc)
@@ -392,9 +393,48 @@ next3_snapshot_read_cow_bitmap(handle_t 
 
 	bitmap_blk = le32_to_cpu(desc->bg_block_bitmap);
 
-	spin_lock(sb_bgl_lock(sbi, block_group));
-	cow_bitmap_blk = gi->bg_cow_bitmap;
-	spin_unlock(sb_bgl_lock(sbi, block_group));
+	/*
+	 * Handle concurrent COW bitmap operations.
+	 * bg_cow_bitmap has 3 states:
+	 * = 0 - uninitialized (after mount and after snapshot take).
+	 * = bg_block_bitmap - marks pending COW of block bitmap.
+	 * other - location of initialized COW bitmap block.
+	 *
+	 * The first task to access block group after mount or snapshot take,
+	 * will read the uninitialized state, mark pending COW state, initialize
+	 * the COW bitmap block and update COW bitmap cache.  Other tasks will
+	 * busy wait until the COW bitmap cache is in initialized state, before
+	 * reading the COW bitmap block.
+	 */
+	do {
+		spin_lock(sb_bgl_lock(sbi, block_group));
+		cow_bitmap_blk = gi->bg_cow_bitmap;
+		if (cow_bitmap_blk == 0)
+			/* mark pending COW of bitmap block */
+			gi->bg_cow_bitmap = bitmap_blk;
+		spin_unlock(sb_bgl_lock(sbi, block_group));
+
+		if (cow_bitmap_blk == 0) {
+			snapshot_debug(3, "initializing COW bitmap #%u "
+					"of snapshot (%u)...\n",
+					block_group, snapshot->i_generation);
+			/* sleep 1 tunable delay unit */
+			snapshot_test_delay(SNAPTEST_BITMAP);
+			break;
+		}
+		if (cow_bitmap_blk == bitmap_blk) {
+			/* wait for another task to COW bitmap block */
+			snapshot_debug_once(2, "waiting for pending COW "
+					    "bitmap #%d...\n", block_group);
+			/*
+			 * This is an unlikely event that can happen only once
+			 * per block_group/snapshot, so msleep(1) is sufficient
+			 * and there is no need for a wait queue.
+			 */
+			msleep(1);
+		}
+		/* XXX: Should we fail after N retries? */
+	} while (cow_bitmap_blk == 0 || cow_bitmap_blk == bitmap_blk);
 	if (cow_bitmap_blk)
 		return sb_bread(sb, cow_bitmap_blk);
 
