===next3_snapshot_hooks_delete.patch===

next3: snapshot hooks - delete blocks

Before deleting file blocks in next3_free_blocks(),
we call the snapshot API snapshot_get_delete_access(),
to optionally move the block to the snapshot file.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/balloc.c b/fs/next3/balloc.c
--- a/fs/next3/balloc.c	2010-07-26 09:22:08.125007766 +0300
+++ b/fs/next3/balloc.c	2010-07-26 09:22:07.615003599 +0300
@@ -477,9 +477,10 @@ void next3_discard_reservation(struct in
  * @count:			number of blocks to free
  * @pdquot_freed_blocks:	pointer to quota
  */
-void next3_free_blocks_sb(handle_t *handle, struct super_block *sb,
-			 next3_fsblk_t block, unsigned long count,
-			 unsigned long *pdquot_freed_blocks)
+void __next3_free_blocks_sb_inode(const char *where, handle_t *handle,
+				  struct super_block *sb, struct inode *inode,
+				  next3_fsblk_t block, unsigned long count,
+				  unsigned long *pdquot_freed_blocks)
 {
 	struct buffer_head *bitmap_bh = NULL;
 	struct buffer_head *gd_bh;
@@ -492,6 +493,7 @@ void next3_free_blocks_sb(handle_t *hand
 	struct next3_sb_info *sbi;
 	int err = 0, ret;
 	next3_grpblk_t group_freed;
+	next3_grpblk_t group_skipped = 0;
 
 	*pdquot_freed_blocks = 0;
 	sbi = NEXT3_SB(sb);
@@ -565,6 +567,20 @@ do_more:
 	jbd_lock_bh_state(bitmap_bh);
 
 	for (i = 0, group_freed = 0; i < count; i++) {
+		ret = next3_snapshot_get_delete_access(handle, inode,
+						       block + i, count - i);
+		if (ret < 0) {
+			next3_journal_abort_handle(where, __func__, NULL,
+						   handle, ret);
+			err = ret;
+			break;
+		}
+		if (ret > 0) {
+			/* 'ret' blocks were moved to snapshot - skip them */
+			group_skipped += ret;
+			i += ret - 1;
+			continue;
+		}
 		/*
 		 * An HJ special.  This is expensive...
 		 */
@@ -637,6 +653,8 @@ do_more:
 	le16_add_cpu(&desc->bg_free_blocks_count, group_freed);
 	spin_unlock(sb_bgl_lock(sbi, block_group));
 	percpu_counter_add(&sbi->s_freeblocks_counter, count);
+	percpu_counter_add(&sbi->s_freeblocks_counter, -group_skipped);
+	group_skipped = 0;
 
 	/* We dirtied the bitmap block */
 	BUFFER_TRACE(bitmap_bh, "dirtied bitmap block");
@@ -678,7 +696,15 @@ void next3_free_blocks(handle_t *handle,
 		printk ("next3_free_blocks: nonexistent device");
 		return;
 	}
-	next3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);
+	next3_free_blocks_sb_inode(handle, sb, inode, block, count,
+				   &dquot_freed_blocks);
+	/*
+	 * The blocks were either freed or moved to active snapshot.
+	 * In both cases the user should no longer be charged for these blocks.
+	 * In the later case, dquot_freed_blocks counts only the freed block.
+	 * The quota on account of the moved blocks has already been returned
+	 * to the user and charged from the owner of the snapshot file.
+	 */
 	if (dquot_freed_blocks)
 		vfs_dq_free_block(inode, dquot_freed_blocks);
 	return;
diff -Nuarp a/fs/next3/next3.h b/fs/next3/next3.h
--- a/fs/next3/next3.h	2010-07-26 09:22:08.195074063 +0300
+++ b/fs/next3/next3.h	2010-07-26 09:22:07.695002639 +0300
@@ -855,9 +855,20 @@ extern next3_fsblk_t next3_new_blocks (h
 			next3_fsblk_t goal, unsigned long *count, int *errp);
 extern void next3_free_blocks (handle_t *handle, struct inode *inode,
 			next3_fsblk_t block, unsigned long count);
-extern void next3_free_blocks_sb (handle_t *handle, struct super_block *sb,
-				 next3_fsblk_t block, unsigned long count,
-				unsigned long *pdquot_freed_blocks);
+extern void __next3_free_blocks_sb_inode(const char *where, handle_t *handle,
+					 struct super_block *sb,
+					 struct inode *inode,
+					 next3_fsblk_t block,
+					 unsigned long count,
+					 unsigned long *pdquot_freed_blocks);
+
+#define next3_free_blocks_sb(handle, sb, block, count, freed) \
+	__next3_free_blocks_sb_inode(__func__, handle, sb, NULL, block, \
+								count, freed)
+#define next3_free_blocks_sb_inode(handle, sb, inode, block, count, freed) \
+	__next3_free_blocks_sb_inode(__func__, handle, sb, inode, block, \
+								count, freed)
+
 extern next3_fsblk_t next3_count_free_blocks (struct super_block *);
 extern void next3_check_blocks_bitmap (struct super_block *);
 extern struct next3_group_desc * next3_get_group_desc(struct super_block * sb,
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:08.235011696 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:07.735004999 +0300
@@ -146,6 +146,27 @@ static inline int next3_snapshot_get_cre
 	return next3_snapshot_cow(handle, NULL, bh, 0);
 }
 
+/*
+ * get_delete_access() - move count blocks to snapshot
+ * @handle:	JBD handle
+ * @inode:	owner of blocks
+ * @block:	address of start @block
+ * @count:	no. of blocks to move
+ *
+ * Called from next3_free_blocks_sb_inode() before deleting blocks with
+ * truncate_mutex held
+ *
+ * Return values:
+ * > 0 - no. of blocks that were moved to snapshot and may not be deleted
+ * = 0 - @block may be deleted
+ * < 0 - error
+ */
+static inline int next3_snapshot_get_delete_access(handle_t *handle,
+		struct inode *inode, next3_fsblk_t block, int count)
+{
+	return next3_snapshot_move(handle, inode, block, count, 1);
+}
+
 
 /*
  * Snapshot constructor/destructor
