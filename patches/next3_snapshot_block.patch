==next3_snapshot_block.patch==

next3: snapshot block operations

Core implementation of special snapshot file block operations.
The argument @create to the function next3_get_blocks_handle()
is re-interpreted as a snapshot block command argument.  The old
argument values 0(=read) and 1(=create) preserve the original
behavior of the function.  The bit field h_cowing in the current
transaction handle is used to prevent COW recursions.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:22:04.025016437 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:22:03.485005787 +0300
@@ -801,6 +801,12 @@ err_out:
  * return = 0, if plain lookup failed.
  * return < 0, error case.
  */
+/*
+ * snapshot_map_blocks() command flags are passed to get_blocks_handle() on its
+ * @create argument.  All places in original code call get_blocks_handle()
+ * with @create 0 or 1.  The behavior of the function remains the same for
+ * these 2 values, while higher bits are used for mapping snapshot blocks.
+ */
 int next3_get_blocks_handle(handle_t *handle, struct inode *inode,
 		sector_t iblock, unsigned long maxblocks,
 		struct buffer_head *bh_result,
diff -Nuarp a/fs/next3/next3_jbd.h b/fs/next3/next3_jbd.h
--- a/fs/next3/next3_jbd.h	2010-07-26 09:22:04.084948882 +0300
+++ b/fs/next3/next3_jbd.h	2010-07-26 09:22:03.554938857 +0300
@@ -94,6 +94,48 @@
 #define NEXT3_QUOTA_DEL_BLOCKS(sb) 0
 #endif
 
+/*
+ * This struct is binary compatible to struct handle_s in include/linux/jbd.h
+ * for building a standalone next3 module.
+ * XXX: be aware of changes to the original struct!!!
+ */
+struct next3_handle_s
+{
+	/* Which compound transaction is this update a part of? */
+	transaction_t		*h_transaction;
+
+	/* Number of remaining buffers we are allowed to dirty: */
+	int			h_buffer_credits;
+
+	/* Reference count on this handle */
+	int			h_ref;
+
+	/* Field for caller's use to track errors through large fs */
+	/* operations */
+	int			h_err;
+
+	/* Flags [no locking] */
+	unsigned int	h_sync:		1;	/* sync-on-close */
+	unsigned int	h_jdata:	1;	/* force data journaling */
+	unsigned int	h_aborted:	1;	/* fatal error on handle */
+	unsigned int	h_cowing:	1;	/* COWing block to snapshot */
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	h_lockdep_map;
+#endif
+};
+
+#ifndef _NEXT3_HANDLE_T
+#define _NEXT3_HANDLE_T
+typedef struct next3_handle_s		next3_handle_t;	/* Next3 COW handle */
+#endif
+
+#define IS_COWING(handle) \
+	((next3_handle_t *)(handle))->h_cowing
+
+#define trace_cow_add(handle, name, num)
+#define trace_cow_inc(handle, name)
+
 int
 next3_mark_iloc_dirty(handle_t *handle,
 		     struct inode *inode,
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:22:04.105017223 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:22:03.565014560 +0300
@@ -14,6 +14,47 @@
 
 #include "snapshot.h"
 
+#define snapshot_debug_hl(n, f, a...)	snapshot_debug_l(n, handle ? 	\
+						 IS_COWING(handle) : 0, f, ## a)
+
+/*
+ * next3_snapshot_map_blocks() - helper function for
+ * next3_snapshot_test_and_cow().  Test if blocks are mapped in snapshot file.
+ * If @block is not mapped and if @cmd is non zero, try to allocate @maxblocks.
+ * Also used by next3_snapshot_create() to pre-allocate snapshot blocks.
+ *
+ * Return values:
+ * > 0 - no. of mapped blocks in snapshot file
+ * = 0 - @block is not mapped in snapshot file
+ * < 0 - error
+ */
+int next3_snapshot_map_blocks(handle_t *handle, struct inode *inode,
+			      next3_snapblk_t block, unsigned long maxblocks,
+			      next3_fsblk_t *mapped, int cmd)
+{
+	struct buffer_head dummy;
+	int err;
+
+	dummy.b_state = 0;
+	dummy.b_blocknr = 0;
+	err = next3_get_blocks_handle(handle, inode, SNAPSHOT_IBLOCK(block),
+				      maxblocks, &dummy, cmd);
+	/*
+	 * next3_get_blocks_handle() returns number of blocks
+	 * mapped. 0 in case of a HOLE.
+	 */
+	if (mapped && err > 0)
+		*mapped = dummy.b_blocknr;
+
+	snapshot_debug_hl(4, "snapshot (%u) map_blocks "
+			"[%lu/%lu] = [%lu/%lu] "
+			"cmd=%d, maxblocks=%lu, mapped=%d\n",
+			inode->i_generation,
+			SNAPSHOT_BLOCK_TUPLE(block),
+			SNAPSHOT_BLOCK_TUPLE(dummy.b_blocknr),
+			cmd, maxblocks, err);
+	return err;
+}
 
 /*
  * next3_snapshot_get_inode_access() - called from next3_get_blocks_handle()
@@ -30,6 +71,27 @@ int next3_snapshot_get_inode_access(hand
 {
 	struct next3_inode_info *ei = NEXT3_I(inode);
 	unsigned int flags = ei->i_flags;
+#ifdef CONFIG_NEXT3_FS_DEBUG
+	next3_fsblk_t block = SNAPSHOT_BLOCK(iblock);
+	unsigned long block_group = (iblock < SNAPSHOT_BLOCK_OFFSET ? -1 :
+			SNAPSHOT_BLOCK_GROUP(block));
+	next3_grpblk_t blk = (iblock < SNAPSHOT_BLOCK_OFFSET ? iblock :
+			SNAPSHOT_BLOCK_GROUP_OFFSET(block));
+	snapshot_debug_hl(4, "snapshot (%u) get_blocks [%d/%lu] count=%d "
+			  "cmd=%d\n", inode->i_generation, blk, block_group,
+			  count, cmd);
+#endif
+
+	if (SNAPMAP_ISSPECIAL(cmd)) {
+		/*
+		 * COWing or moving blocks to active snapshot
+		 */
+		BUG_ON(!handle || !IS_COWING(handle));
+		BUG_ON(!(flags & NEXT3_SNAPFILE_ACTIVE_FL));
+		BUG_ON(iblock < SNAPSHOT_BLOCK_OFFSET);
+		return 0;
+	} else if (cmd)
+		BUG_ON(handle && IS_COWING(handle));
 
 	if (!(flags & NEXT3_SNAPFILE_LIST_FL)) {
 		return 0;
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:22:04.114946311 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:22:03.584938967 +0300
@@ -93,6 +93,48 @@ enum next3_bh_state_bits {
 BUFFER_FNS(Partial_Write, partial_write)
 
 
+/*
+ * snapshot_map_blocks() command flags passed to get_blocks_handle() on its
+ * @create argument.  All places in original code call get_blocks_handle()
+ * with @create 0 or 1.  The behavior of the function remains the same for
+ * these 2 values, while higher bits are used for mapping snapshot blocks.
+ */
+/* original meaning - only check if blocks are mapped */
+#define SNAPMAP_READ	0
+/* original meaning - allocate missing blocks and indirect blocks */
+#define SNAPMAP_WRITE	0x1
+/* creating COWed block - handle COW race conditions */
+#define SNAPMAP_COW	0x2
+/* moving blocks to snapshot - allocate only indirect blocks */
+#define SNAPMAP_MOVE	0x4
+/* bypass journal and sync allocated indirect blocks directly to disk */
+#define SNAPMAP_SYNC	0x8
+/* creating COW bitmap - handle COW races and bypass journal */
+#define SNAPMAP_BITMAP	(SNAPMAP_COW|SNAPMAP_SYNC)
+
+/* original @create flag test - only check map or create map? */
+#define SNAPMAP_ISREAD(cmd)	((cmd) == SNAPMAP_READ)
+#define SNAPMAP_ISWRITE(cmd)	((cmd) == SNAPMAP_WRITE)
+#define SNAPMAP_ISCREATE(cmd)	((cmd) != SNAPMAP_READ)
+/* test special cases when mapping snapshot blocks */
+#define SNAPMAP_ISSPECIAL(cmd)	((cmd) & ~SNAPMAP_WRITE)
+#define SNAPMAP_ISCOW(cmd)	((cmd) & SNAPMAP_COW)
+#define SNAPMAP_ISMOVE(cmd)	((cmd) & SNAPMAP_MOVE)
+#define SNAPMAP_ISSYNC(cmd)	((cmd) & SNAPMAP_SYNC)
+
+/* helper functions for next3_snapshot_create() */
+extern int next3_snapshot_map_blocks(handle_t *handle, struct inode *inode,
+				     next3_snapblk_t block,
+				     unsigned long maxblocks,
+				     next3_fsblk_t *mapped, int cmd);
+/* helper function for next3_snapshot_take() */
+extern void next3_snapshot_copy_buffer(struct buffer_head *sbh,
+					   struct buffer_head *bh,
+					   const char *mask);
+/* helper function for next3_snapshot_get_block() */
+extern int next3_snapshot_read_block_bitmap(struct super_block *sb,
+		unsigned int block_group, struct buffer_head *bitmap_bh);
+
 #define next3_snapshot_cow(handle, inode, bh, cow) 0
 
 #define next3_snapshot_move(handle, inode, block, num, move) (num)
diff -Nuarp a/include/linux/jbd.h b/include/linux/jbd.h
--- a/include/linux/jbd.h	2010-07-26 09:22:03.934944875 +0300
+++ b/include/linux/jbd.h	2010-07-26 09:22:03.404938703 +0300
@@ -375,12 +375,17 @@ struct handle_s
 	unsigned int	h_sync:		1;	/* sync-on-close */
 	unsigned int	h_jdata:	1;	/* force data journaling */
 	unsigned int	h_aborted:	1;	/* fatal error on handle */
+	unsigned int	h_cowing:	1;	/* COWing block to snapshot */
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	h_lockdep_map;
 #endif
 };
 
+#ifndef _NEXT3_HANDLE_T
+#define _NEXT3_HANDLE_T
+typedef struct handle_s		next3_handle_t;	/* Next3 COW handle */
+#endif
 
 /* The transaction_t type is the guts of the journaling mechanism.  It
  * tracks a compound transaction through its various states:
