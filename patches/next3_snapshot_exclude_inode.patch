===next3_snapshot_exclude_inode.patch===

next3: snapshot exclude - the exclude inode

The exclude inode owns all the exclude bitmap blocks.
The exclude inode is pre-allocated by 'tune2fs -O exclude_inode'.
The location of exclude bitmap blocks is read on mount time and cached
in the group descriptors.  The exclude inode is extended upon online
and offline resize operations when block groups are added.

Signed-off-by: Amir Goldstein <amir73il@users.sf.net>

--------------------------------------------------------------------------------
diff -Nuarp a/fs/next3/inode.c b/fs/next3/inode.c
--- a/fs/next3/inode.c	2010-07-26 09:21:51.434752350 +0300
+++ b/fs/next3/inode.c	2010-07-26 09:21:50.864857486 +0300
@@ -3379,6 +3379,28 @@ struct inode *next3_iget(struct super_bl
 		SNAPSHOT_SET_DISABLED(inode);
 	}
 
+	if (next3_snapshot_exclude_inode(inode)) {
+		if (ei->i_data[NEXT3_IND_BLOCK] != 0) {
+			/* cannot link DIND branch to IND branch */
+			brelse(bh);
+			ret = -EIO;
+			goto bad_inode;
+		}
+		/*
+		 * Link the DIND branch to the IND branch, so we can read
+		 * exclude bitmap block addresses with next3_bread().
+		 *
+		 * My reasons to justify this hack are:
+		 * 1. I like shortcuts and it helped keeping my patch small
+		 * 2. No user has access to the exclude inode
+		 * 3. The exclude inode is never truncated on a mounted next3
+		 * 4. The 'expose' is only to the in-memory inode (fsck safe)
+		 * 5. A healthy exclude inode has blocks only on the DIND branch
+		 * XXX: is that a problem?
+		 */
+		ei->i_data[NEXT3_IND_BLOCK] = ei->i_data[NEXT3_DIND_BLOCK];
+	}
+
 	INIT_LIST_HEAD(&ei->i_orphan);
 
 	if (inode->i_ino >= NEXT3_FIRST_INO(inode->i_sb) + 1 &&
@@ -3611,6 +3633,21 @@ static int next3_do_update_inode(handle_
 		raw_inode->i_flags &= cpu_to_le32(~NEXT3_FL_SNAPSHOT_DYN_MASK);
 	}
 
+	if (next3_snapshot_exclude_inode(inode)) {
+		if (raw_inode->i_block[NEXT3_IND_BLOCK] !=
+				raw_inode->i_block[NEXT3_DIND_BLOCK]) {
+			err = -EIO;
+			goto out_brelse;
+		}
+		/*
+		 * Remove duplicate reference to exclude inode indirect blocks
+		 * which was exposed in next3_iget() before storing to disk.
+		 * It was needed only in memory and we don't want to break
+		 * compatibility with ext2's disk format.
+		 */
+		raw_inode->i_block[NEXT3_IND_BLOCK] = 0;
+	}
+
 	BUFFER_TRACE(bh, "call next3_journal_dirty_metadata");
 	rc = next3_journal_dirty_metadata(handle, bh);
 	if (!err)
diff -Nuarp a/fs/next3/next3.h b/fs/next3/next3.h
--- a/fs/next3/next3.h	2010-07-26 09:21:51.484826057 +0300
+++ b/fs/next3/next3.h	2010-07-26 09:21:50.914819846 +0300
@@ -79,6 +79,7 @@
 #define NEXT3_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 #define NEXT3_RESIZE_INO		 7	/* Reserved group descriptors inode */
 #define NEXT3_JOURNAL_INO	 8	/* Journal inode */
+#define NEXT3_EXCLUDE_INO		 9	/* Snapshot exclude inode */
 
 /* First non-reserved inode for old next3 filesystems */
 #define NEXT3_GOOD_OLD_FIRST_INO	11
@@ -652,6 +653,7 @@ static inline int next3_valid_inum(struc
 	return ino == NEXT3_ROOT_INO ||
 		ino == NEXT3_JOURNAL_INO ||
 		ino == NEXT3_RESIZE_INO ||
+		ino == NEXT3_EXCLUDE_INO ||
 		(ino >= NEXT3_FIRST_INO(sb) &&
 		 ino <= le32_to_cpu(NEXT3_SB(sb)->s_es->s_inodes_count));
 }
diff -Nuarp a/fs/next3/resize.c b/fs/next3/resize.c
--- a/fs/next3/resize.c	2010-07-26 09:21:51.464818537 +0300
+++ b/fs/next3/resize.c	2010-07-26 09:21:50.884746513 +0300
@@ -44,6 +44,14 @@ static int verify_group_input(struct sup
 	input->free_blocks_count = free_blocks_count =
 		input->blocks_count - 2 - overhead - sbi->s_itb_per_group;
 
+	if (NEXT3_HAS_COMPAT_FEATURE(sb,
+		NEXT3_FEATURE_COMPAT_EXCLUDE_INODE)) {
+		/* reserve first free block for exclude bitmap */
+		itend++;
+		free_blocks_count--;
+		input->free_blocks_count = free_blocks_count;
+	}
+
 	if (test_opt(sb, DEBUG))
 		printk(KERN_DEBUG "NEXT3-fs: adding %s group %u: %u blocks "
 		       "(%d free, %u reserved)\n",
@@ -285,6 +293,11 @@ static int setup_new_group_blocks(struct
 		   input->inode_bitmap - start);
 	next3_set_bit(input->inode_bitmap - start, bh->b_data);
 
+	if (NEXT3_HAS_COMPAT_FEATURE(sb,
+		NEXT3_FEATURE_COMPAT_EXCLUDE_INODE))
+		/* clear reserved exclude bitmap block */
+		itend++;
+
 	/* Zero out all of the inode table blocks */
 	for (block = input->inode_table, bit = block - start;
 	     block < itend; bit++, block++) {
@@ -782,6 +795,11 @@ int next3_group_add(struct super_block *
 	struct buffer_head *primary = NULL;
 	struct next3_group_desc *gdp;
 	struct inode *inode = NULL;
+	struct next3_group_info *gi = NEXT3_SB(sb)->s_group_info + input->group;
+	struct inode *exclude_inode = NULL;
+	struct buffer_head *exclude_bh = NULL;
+	__le32 exclude_bitmap = 0;
+	int credits;
 	handle_t *handle;
 	int gdb_off, gdb_num;
 	int err, err2;
@@ -824,6 +842,31 @@ int next3_group_add(struct super_block *
 		}
 	}
 
+	if (NEXT3_HAS_COMPAT_FEATURE(sb,
+		NEXT3_FEATURE_COMPAT_EXCLUDE_INODE)) {
+		int dind_offset = input->group / SNAPSHOT_ADDR_PER_BLOCK;
+		int ind_offset = input->group % SNAPSHOT_ADDR_PER_BLOCK;
+
+		exclude_inode = next3_iget(sb, NEXT3_EXCLUDE_INO);
+		if (IS_ERR(exclude_inode)) {
+			next3_warning(sb, __func__,
+				     "Error opening exclude inode");
+			return PTR_ERR(exclude_inode);
+		}
+
+		/* exclude bitmap blocks addresses are exposed on the IND
+		   branch */
+		exclude_bh = next3_bread(NULL, exclude_inode,
+					 NEXT3_IND_BLOCK+dind_offset, 0, &err);
+		if (!exclude_bh) {
+			snapshot_debug(1, "failed to read exclude inode "
+				       "indirect[%d] block\n", dind_offset);
+			err = -EIO;
+			goto exit_put;
+		}
+		exclude_bitmap = ((__le32 *)exclude_bh->b_data)[ind_offset];
+	}
+
 	if ((err = verify_group_input(sb, input)))
 		goto exit_put;
 
@@ -837,9 +880,15 @@ int next3_group_add(struct super_block *
 	 * are adding a group with superblock/GDT backups  we will also
 	 * modify each of the reserved GDT dindirect blocks.
 	 */
-	handle = next3_journal_start_sb(sb,
-				       next3_bg_has_super(sb, input->group) ?
-				       3 + reserved_gdb : 4);
+	credits = next3_bg_has_super(sb, input->group) ?
+		3 + reserved_gdb : 4;
+	if (exclude_inode && !exclude_bitmap)
+		/*
+		 * we will also be modifying the exclude inode
+		 * and one of it's indirect blocks
+		 */
+		credits += 2;
+	handle = next3_journal_start_sb(sb, credits);
 	if (IS_ERR(handle)) {
 		err = PTR_ERR(handle);
 		goto exit_put;
@@ -901,6 +950,50 @@ int next3_group_add(struct super_block *
 	gdp->bg_free_blocks_count = cpu_to_le16(input->free_blocks_count);
 	gdp->bg_free_inodes_count = cpu_to_le16(NEXT3_INODES_PER_GROUP(sb));
 
+	if (!exclude_inode)
+		goto no_exclude_inode;
+	if (exclude_bitmap) {
+		/*
+		 * offline resize from a bigger size filesystem may leave
+		 * allocated exclude bitmap blocks of unused block groups
+		 */
+		snapshot_debug(2, "reusing old exclude bitmap #%d block (%u)\n",
+			       input->group, le32_to_cpu(exclude_bitmap));
+	} else {
+		/* set exclude bitmap block to first free block */
+		next3_fsblk_t first_free =
+			input->inode_table + sbi->s_itb_per_group;
+		struct next3_iloc iloc;
+		loff_t i_size;
+
+		err = next3_journal_get_write_access(handle, exclude_bh);
+		if (err)
+			goto exit_journal;
+		err = next3_reserve_inode_write(handle, exclude_inode, &iloc);
+		if (err)
+			goto exit_journal;
+
+		exclude_bitmap = cpu_to_le32(first_free);
+		snapshot_debug(2, "allocated new exclude bitmap #%d block "
+			       "("E3FSBLK")\n", input->group, first_free);
+		next3_journal_dirty_metadata(handle, exclude_bh);
+
+		/*
+		 * Update exclude inode size and blocks.
+		 * Online resize can only extend f/s and exclude inode.
+		 * Offline resize can shrink f/s but it doesn't shrink
+		 * exclude inode.
+		 */
+		i_size = SNAPSHOT_IBLOCK(input->group)
+				 << SNAPSHOT_BLOCK_SIZE_BITS;
+		i_size_write(exclude_inode, i_size);
+		NEXT3_I(exclude_inode)->i_disksize = i_size;
+		exclude_inode->i_blocks += sb->s_blocksize >> 9;
+		next3_mark_iloc_dirty(handle, exclude_inode, &iloc);
+	}
+	/* update exclude bitmap cache */
+	gi->bg_exclude_bitmap = exclude_bitmap;
+no_exclude_inode:
 	/*
 	 * Make the new blocks and inodes valid next.  We do this before
 	 * increasing the group count so that once the group is enabled,
@@ -966,6 +1059,8 @@ exit_journal:
 			       primary->b_size);
 	}
 exit_put:
+	brelse(exclude_bh);
+	iput(exclude_inode);
 	iput(inode);
 	return err;
 } /* next3_group_add */
diff -Nuarp a/fs/next3/snapshot.c b/fs/next3/snapshot.c
--- a/fs/next3/snapshot.c	2010-07-26 09:21:51.524756232 +0300
+++ b/fs/next3/snapshot.c	2010-07-26 09:21:50.944785237 +0300
@@ -789,6 +789,11 @@ int next3_snapshot_test_and_cow(const ch
 
 	next3_snapshot_trace_cow(where, handle, sb, inode, bh, block, cow);
 
+	if (inode && next3_snapshot_exclude_inode(inode)) {
+		snapshot_debug_hl(4, "exclude bitmap update - "
+				  "skip block cow!\n");
+		return 0;
+	}
 	if (IS_COWING(handle)) {
 		/* avoid recursion on active snapshot updates */
 		WARN_ON(inode && inode != active_snapshot);
diff -Nuarp a/fs/next3/snapshot_ctl.c b/fs/next3/snapshot_ctl.c
--- a/fs/next3/snapshot_ctl.c	2010-07-26 09:21:51.524756232 +0300
+++ b/fs/next3/snapshot_ctl.c	2010-07-26 09:21:50.954817264 +0300
@@ -1132,9 +1132,212 @@ out_err:
  * Snapshot constructor/destructor
  */
 
-/* with no exclude inode, exclude bitmap is reset to 0 */
-#define next3_snapshot_init_bitmap_cache(sb, create)	\
-		next3_snapshot_reset_bitmap_cache(sb, 1)
+/*
+ * next3_exclude_inode_bread - read indirect block from exclude inode
+ * @handle:	JBD handle (NULL is !@create)
+ * @inode:	exclude inode
+ * @grp:	block group
+ * @create:	if true, try to allocate missing indirect block
+ *
+ * Helper function for next3_snapshot_init_bitmap_cache().
+ * Called under sb_lock and before snapshots are loaded, so changes made to
+ * exclude inode are not COWed.
+ *
+ * Returns indirect block buffer or NULL if not allocated.
+ */
+static struct buffer_head *next3_exclude_inode_bread(handle_t *handle,
+		struct inode *inode, int grp, int create)
+{
+	int dind_offset = grp / SNAPSHOT_ADDR_PER_BLOCK;
+	struct buffer_head *ind_bh;
+	int err;
+
+	/* exclude bitmap blocks addresses are exposed on the IND branch */
+	ind_bh = next3_bread(NULL, inode, NEXT3_IND_BLOCK + dind_offset,
+						 0, &err);
+	if (ind_bh)
+		return ind_bh;
+
+	snapshot_debug(1, "failed to read exclude inode indirect[%d] block\n",
+			dind_offset);
+	if (!create)
+		return NULL;
+
+	err = extend_or_restart_transaction(handle, NEXT3_RESERVE_TRANS_BLOCKS);
+	if (err)
+		return NULL;
+	ind_bh = next3_bread(handle, inode, NEXT3_IND_BLOCK + dind_offset,
+			create, &err);
+	if (!ind_bh) {
+		snapshot_debug(1, "failed to allocate exclude "
+				"inode indirect[%d] block\n",
+				dind_offset);
+		return NULL;
+	}
+	snapshot_debug(2, "allocated exclude bitmap "
+			"indirect[%d] block (%lld)\n",
+			dind_offset, (long long)ind_bh->b_blocknr);
+	return ind_bh;
+}
+
+/*
+ * next3_exclude_inode_getblk - read address of exclude bitmap block
+ * @handle:	JBD handle (NULL is !@create)
+ * @inode:	exclude inode
+ * @grp:	block group
+ * @create:	if true, try to allocate missing blocks
+  *
+ * Helper function for next3_snapshot_init_bitmap_cache().
+ * Called under sb_lock and before snapshots are loaded, so changes made to
+ * exclude inode are not COWed.
+ *
+ * Returns exclude bitmap block address (little endian) or 0 if not allocated.
+ */
+static __le32 next3_exclude_inode_getblk(handle_t *handle,
+		struct inode *inode, int grp, int create)
+{
+	int ind_offset = grp % SNAPSHOT_ADDR_PER_BLOCK;
+	struct buffer_head *bh, *ind_bh = NULL;
+	__le32 exclude_bitmap = 0;
+	int err = 0;
+
+	/* read exclude inode indirect block */
+	ind_bh = next3_exclude_inode_bread(handle, inode, grp, create);
+	if (!ind_bh)
+		return 0;
+
+	if (grp >= NEXT3_SB(inode->i_sb)->s_groups_count)
+		/* past last block group - just allocating indirect blocks */
+		goto out;
+
+	exclude_bitmap = ((__le32 *)ind_bh->b_data)[ind_offset];
+	if (exclude_bitmap)
+		goto out;
+	if (!create)
+		goto alloc_out;
+
+	/* try to allocate missing exclude bitmap(+ind+dind) block */
+	err = extend_or_restart_transaction(handle,
+			NEXT3_RESERVE_TRANS_BLOCKS);
+	if (err)
+		goto alloc_out;
+
+	/* exclude bitmap blocks are mapped on the DIND branch */
+	bh = next3_getblk(handle, inode, SNAPSHOT_IBLOCK(grp), create, &err);
+	if (!bh)
+		goto alloc_out;
+	brelse(bh);
+	exclude_bitmap = ((__le32 *)ind_bh->b_data)[ind_offset];
+alloc_out:
+	if (exclude_bitmap)
+		snapshot_debug(2, "allocated exclude bitmap #%d block "
+				"(%u)\n", grp,
+				le32_to_cpu(exclude_bitmap));
+	else
+		snapshot_debug(1, "failed to allocate exclude "
+				"bitmap #%d block (err = %d)\n",
+				grp, err);
+out:
+	brelse(ind_bh);
+	return exclude_bitmap;
+}
+
+/*
+ * next3_snapshot_init_bitmap_cache():
+ *
+ * Init the COW/exclude bitmap cache for all block groups.
+ * COW bitmap cache is set to 0 (lazy init on first access to block group).
+ * Read exclude bitmap blocks addresses from exclude inode and store them
+ * in block group descriptor.  If @create is true, Try to allocate missing
+ * exclude bitmap blocks.
+ *
+ * Called from snapshot_load() under sb_lock during mount time.
+ * Returns 0 on success and <0 on error.
+ */
+static int next3_snapshot_init_bitmap_cache(struct super_block *sb, int create)
+{
+	struct next3_group_info *gi = NEXT3_SB(sb)->s_group_info;
+	struct next3_sb_info *sbi = NEXT3_SB(sb);
+	handle_t *handle = NULL;
+	struct inode *inode;
+	__le32 exclude_bitmap = 0;
+	int grp, max_groups = sbi->s_groups_count;
+	int err = 0, ret;
+	loff_t i_size;
+
+	/* reset COW/exclude bitmap cache */
+	err = next3_snapshot_reset_bitmap_cache(sb, 1);
+	if (err)
+		return err;
+
+	if (!NEXT3_HAS_COMPAT_FEATURE(sb,
+				      NEXT3_FEATURE_COMPAT_EXCLUDE_INODE)) {
+		/* exclude inode is a recommended feature - don't force it */
+		snapshot_debug(1, "warning: exclude_inode feature not set - "
+			       "snapshot merge might not free all unused "
+			       "blocks!\n");
+		return 0;
+	}
+
+	inode = next3_iget(sb, NEXT3_EXCLUDE_INO);
+	if (IS_ERR(inode)) {
+		snapshot_debug(1, "warning: bad exclude inode - "
+				"no exclude bitmap!\n");
+		return PTR_ERR(inode);
+	}
+
+	if (create) {
+		/* start large transaction that will be extended/restarted */
+		handle = next3_journal_start(inode, NEXT3_MAX_TRANS_DATA);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		/* number of groups the filesystem can grow to */
+		max_groups = sbi->s_gdb_count +
+			le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);
+		max_groups *= NEXT3_DESC_PER_BLOCK(sb);
+	}
+
+	/*
+	 * Init exclude bitmap blocks for all existing block groups and
+	 * allocate indirect blocks for all reserved block groups.
+	 */
+	err = -EIO;
+	for (grp = 0; grp < max_groups; grp++, gi++) {
+		exclude_bitmap = next3_exclude_inode_getblk(handle, inode, grp,
+				create);
+		if (create && grp >= sbi->s_groups_count)
+			/* only allocating indirect blocks with getblk above */
+			continue;
+
+		if (create && !exclude_bitmap)
+			goto out;
+
+		gi->bg_exclude_bitmap = le32_to_cpu(exclude_bitmap);
+		snapshot_debug(2, "update exclude bitmap #%d cache "
+			       "(block=%lu)\n", grp,
+			       gi->bg_exclude_bitmap);
+	}
+
+	err = 0;
+	if (!create)
+		goto out;
+
+	i_size = SNAPSHOT_IBLOCK(max_groups) << SNAPSHOT_BLOCK_SIZE_BITS;
+	if (NEXT3_I(inode)->i_disksize >= i_size)
+		goto out;
+	i_size_write(inode, i_size);
+	NEXT3_I(inode)->i_disksize = i_size;
+	err = next3_mark_inode_dirty(handle, inode);
+out:
+	if (handle) {
+		ret = next3_journal_stop(handle);
+		if (!err)
+			err = ret;
+	}
+	iput(inode);
+	return err;
+}
+
 
 /*
  * next3_snapshot_load - load the on-disk snapshot list to memory.
diff -Nuarp a/fs/next3/snapshot.h b/fs/next3/snapshot.h
--- a/fs/next3/snapshot.h	2010-07-26 09:21:51.534819028 +0300
+++ b/fs/next3/snapshot.h	2010-07-26 09:21:50.964891396 +0300
@@ -344,6 +344,10 @@ static inline int next3_snapshot_list(st
 	return NEXT3_I(inode)->i_flags & NEXT3_SNAPFILE_LIST_FL;
 }
 
+static inline int next3_snapshot_exclude_inode(struct inode *inode)
+{
+	return (inode->i_ino == NEXT3_EXCLUDE_INO);
+}
 
 /*
  * next3_snapshot_excluded():
@@ -367,6 +371,9 @@ static inline int next3_snapshot_exclude
 	/* snapshot files are 'ignored' */
 	if (next3_snapshot_file(inode))
 		return -1;
+	/* exclude inode is 'ignored' */
+	if (next3_snapshot_exclude_inode(inode))
+		return -1;
 	return 0;
 }
 
