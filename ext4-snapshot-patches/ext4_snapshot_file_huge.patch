Index: linux-2.6.37.1.x/fs/ext4/inode.c
===================================================================
--- linux-2.6.37.1.x.orig/fs/ext4/inode.c	2010-11-26 20:59:54.000000000 +0530
+++ linux-2.6.37.1.x/fs/ext4/inode.c	2010-11-26 21:08:29.000000000 +0530
@@ -326,6 +326,9 @@
 		double_blocks = (1 << (ptrs_bits * 2));
 	int n = 0;
 	int final = 0;
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	int tind;
+#endif
 
 	if (i_block < direct_blocks) {
 		offsets[n++] = i_block;
@@ -345,6 +348,18 @@
 		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
 		offsets[n++] = i_block & (ptrs - 1);
 		final = ptrs;
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	} else if (ext4_snapshot_file(inode) &&
+			(tind = (i_block >> (ptrs_bits * 3))) <
+			EXT4_SNAPSHOT_NTIND_BLOCKS) {
+		/* use up to 4 triple indirect blocks to map 2^32 blocks */
+		i_block -= (tind << (ptrs_bits * 3));
+		offsets[n++] = EXT4_TIND_BLOCK + tind;
+		offsets[n++] = i_block >> (ptrs_bits * 2);
+		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
+		offsets[n++] = i_block & (ptrs - 1);
+		final = ptrs;
+#endif
 	} else {
 		ext4_warning(inode->i_sb, "block %lu > max in inode %lu",
 			     i_block + direct_blocks +
@@ -4888,6 +4903,15 @@
 	ext4_lblk_t last_block;
 	unsigned blocksize = inode->i_sb->s_blocksize;
 
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	/* prevent partial truncate of snapshot files */
+	if (ext4_snapshot_file(inode) && inode->i_size != 0) {
+		snapshot_debug(1, "snapshot file (%lu) cannot be partly "
+				"truncated!\n", inode->i_ino);
+		return;
+	}
+
+#endif
 #ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_PERM
 	/* prevent truncate of files on snapshot list */
 	if (ext4_snapshot_list(inode)) {
@@ -5014,6 +5038,22 @@
 		;
 	}
 
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	if (ext4_snapshot_file(inode)) {
+		int i;
+
+		/* Kill the remaining snapshot file triple indirect trees */
+		for (i = 1; i < EXT4_SNAPSHOT_NTIND_BLOCKS; i++) {
+			nr = i_data[EXT4_TIND_BLOCK + i];
+			if (!nr)
+				continue;
+			ext4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);
+			i_data[EXT4_TIND_BLOCK + i] = 0;
+		}
+	}
+
+#endif
+
 	up_write(&ei->i_data_sem);
 	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
 	ext4_mark_inode_dirty(handle, inode);
@@ -5239,7 +5279,21 @@
 	struct inode *inode = &(ei->vfs_inode);
 	struct super_block *sb = inode->i_sb;
 
-	if (EXT4_HAS_RO_COMPAT_FEATURE(sb,
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	if (ext4_snapshot_file(inode)) {
+		/* we never set i_blocks_high, but fsck may do it when it fixes
+		   i_blocks */
+		i_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |
+					le32_to_cpu(raw_inode->i_blocks_lo);
+		if (ei->i_flags & EXT4_HUGE_FILE_FL) {
+			/* i_blocks represent file system block size */
+			return i_blocks  << (inode->i_blkbits - 9);
+		} else {
+			return i_blocks;
+		}
+	} else
+#endif
+ 	if (EXT4_HAS_RO_COMPAT_FEATURE(sb,
 				EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {
 		/* we are using combined 48 bit field */
 		i_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |
@@ -5307,9 +5361,15 @@
 		 * recovery code: that's fine, we're about to complete
 		 * the process of deleting those. */
 	}
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
+	inode->i_blocks = ext4_inode_blocks(raw_inode, ei);
+#else
+
 	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
 	inode->i_blocks = ext4_inode_blocks(raw_inode, ei);
 	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);
+#endif
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT))
 		ei->i_file_acl |=
 			((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;
@@ -5330,6 +5390,20 @@
 #ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_STORE
 
 	if (ext4_snapshot_file(inode)) {
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+		/*
+		 * ei->i_data[] has more blocks than raw_inode->i_block[].
+		 * Snapshot files don't use the first EXT4_NDIR_BLOCKS of
+		 * ei->i_data[] and store the extra blocks at the
+		 * begining of raw_inode->i_block[].
+		 */
+		for (block = EXT4_N_BLOCKS; block < EXT4_SNAPSHOT_N_BLOCKS;
+				block++) {
+			ei->i_data[block] =
+				raw_inode->i_block[block-EXT4_N_BLOCKS];
+			ei->i_data[block-EXT4_N_BLOCKS] = 0;
+		}
+#endif
 		ei->i_next_snapshot_ino =
 			le32_to_cpu(raw_inode->i_next_snapshot);
 		/*
@@ -5495,7 +5569,11 @@
 	}
 	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))
 		return -EFBIG;
-
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	/* snapshot files may be represented as huge files */
+	if (!ext4_snapshot_file(inode))
+		return -EFBIG;
+#endif
 	if (i_blocks <= 0xffffffffffffULL) {
 		/*
 		 * i_blocks can be represented in a 48 bit variable
@@ -5581,7 +5659,7 @@
 	if (ei->i_disksize > 0x7fffffffULL) {
 		struct super_block *sb = inode->i_sb;
 		if (!EXT4_HAS_RO_COMPAT_FEATURE(sb,
-				EXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||
+                                        EXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||
 				EXT4_SB(sb)->s_es->s_rev_level ==
 				cpu_to_le32(EXT4_GOOD_OLD_REV)) {
 			/* If this is the first large file
@@ -5625,6 +5703,19 @@
 	}
 #ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_STORE
 	if (ext4_snapshot_file(inode)) {
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+		/*
+		 * ei->i_data[] has more blocks than raw_inode->i_block[].
+		 * Snapshot files don't use the first EXT4_NDIR_BLOCKS of
+		 * ei->i_data[] and store the extra blocks at the
+		 * begining of raw_inode->i_block[].
+		 */
+		for (block = EXT4_N_BLOCKS; block < EXT4_SNAPSHOT_N_BLOCKS;
+				block++) {
+			raw_inode->i_block[block-EXT4_N_BLOCKS] =
+				ei->i_data[block];
+		}
+#endif
 		raw_inode->i_next_snapshot =
 			cpu_to_le32(ei->i_next_snapshot_ino);
 		/* dynamic snapshot flags are not stored on-disk */
@@ -5641,6 +5732,12 @@
 
 	ext4_update_inode_fsync_trans(handle, inode, 0);
 out_brelse:
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+		ext4_warning(inode->i_sb,
+				"ino=%lu, i_blocks=%lld is too big",
+				inode->i_ino, (long long)inode->i_blocks);
+#endif
+
 	brelse(bh);
 	ext4_std_error(inode->i_sb, err);
 	return err;
Index: linux-2.6.37.1.x/fs/ext4/Kconfig
===================================================================
--- linux-2.6.37.1.x.orig/fs/ext4/Kconfig	2010-11-26 20:59:54.000000000 +0530
+++ linux-2.6.37.1.x/fs/ext4/Kconfig	2010-11-26 21:05:51.000000000 +0530
@@ -162,3 +162,16 @@
 	  Snapshot inode is stored differently in memory and on disk.
 	  During store and load of snapshot inode, some of the inode flags
 	  and fields are converted.
+
+config EXT4_FS_SNAPSHOT_FILE_HUGE
+	bool "snapshot file - increase maximum file size limit to 16TB"
+	depends on EXT4_FS_SNAPSHOT_FILE
+	default y
+	help
+	  Files larger than 2TB use Ext4 huge_file flag to store i_blocks
+	  in file system blocks units, so the upper limit on snapshot actual
+	  size is increased from 512*2^32 = 2TB to 4K*2^32 = 16TB,
+	  which is also the upper limit on file system size.
+	  To map 2^32 logical blocks, 4 triple indirect blocks are used instead
+	  of just one.  The extra 3 triple indirect blocks are stored in-place
+	  of direct blocks, which are not in use by snapshot files.
Index: linux-2.6.37.1.x/fs/ext4/ext4.h
===================================================================
--- linux-2.6.37.1.x.orig/fs/ext4/ext4.h	2010-11-26 21:01:37.000000000 +0530
+++ linux-2.6.37.1.x/fs/ext4/ext4.h	2010-11-26 21:05:51.000000000 +0530
@@ -344,6 +344,21 @@
 #define	EXT4_DIND_BLOCK			(EXT4_IND_BLOCK + 1)
 #define	EXT4_TIND_BLOCK			(EXT4_DIND_BLOCK + 1)
 #define	EXT4_N_BLOCKS			(EXT4_TIND_BLOCK + 1)
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+/*
+ * Snapshot files have different indirection mapping that can map up to 2^32
+ * logical blocks, so they can cover the mapped filesystem block address space.
+ * Ext4 must use either 4K or 8K blocks (depending on PAGE_SIZE).
+ * With 8K blocks, 1 triple indirect block maps 2^33 logical blocks.
+ * With 4K blocks (the system default), each triple indirect block maps 2^30
+ * logical blocks, so 4 triple indirect blocks map 2^32 logical blocks.
+ * Snapshot files in small filesystems (<= 4G), use only 1 double indirect
+ * block to map the entire filesystem.
+ */
+#define	EXT4_SNAPSHOT_NTIND_BLOCKS	4
+#define	EXT4_SNAPSHOT_N_BLOCKS		(EXT4_TIND_BLOCK + \
+					 EXT4_SNAPSHOT_NTIND_BLOCKS)
+#endif
 
 /*
  * Inode flags
@@ -851,7 +866,11 @@
  * fourth extended file system inode data in memory
  */
 struct ext4_inode_info {
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	__le32	i_data[EXT4_SNAPSHOT_N_BLOCKS]; /* unconverted */
+#else
 	__le32	i_data[15];	/* unconverted */
+#endif
 	__u32	i_dtime;
 	ext4_fsblk_t	i_file_acl;
 
Index: linux-2.6.37.1.x/fs/ext4/super.c
===================================================================
--- linux-2.6.37.1.x.orig/fs/ext4/super.c	2010-11-26 20:59:54.000000000 +0530
+++ linux-2.6.37.1.x/fs/ext4/super.c	2010-11-26 21:05:51.000000000 +0530
@@ -2312,7 +2312,11 @@
 
 	res += 1LL << (bits-2);
 	res += 1LL << (2*(bits-2));
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	res += EXT4_SNAPSHOT_NTIND_BLOCKS * (1LL << (3*(bits-2)));
+#else
 	res += 1LL << (3*(bits-2));
+#endif
 	res <<= bits;
 	if (res > upper_limit)
 		res = upper_limit;
@@ -3249,6 +3253,18 @@
 		goto failed_mount;
 
 	blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);
+#ifdef CONFIG_EXT4_FS_SNAPSHOT_FILE_HUGE
+	/*
+	 * Large file size enabled file system can only be mounted
+	 * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF
+	 */
+	if (!(sb->s_flags & MS_RDONLY) && sizeof(blkcnt_t) < sizeof(u64)) {
+		printk(KERN_ERR "EXT4-fs: Filesystem with snapshots support "
+				"cannot be mounted RDWR without "
+				"CONFIG_LBDAF");
+		goto failed_mount;
+	}
+#endif
 
 #ifdef CONFIG_EXT4_FS_SNAPSHOT
 	/* Block size must be equal to page size */
